<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="vitalije.20170720214543.2"><vh>About this experiment</vh>
<v t="vitalije.20170721074235.1"><vh>&lt;&lt;about exp-3 dev&gt;&gt;</vh></v>
</v>
<v t="vitalije.20170720180020.1"><vh>exp-3 dev @key=Alt-4</vh>
<v t="vitalije.20170720214432.1"><vh>importing derived files</vh>
<v t="vitalije.20170720214432.2"><vh>derived-files</vh>
<v t="vitalije.20170720214432.3"><vh>false positives</vh></v>
<v t="vitalije.20170720214432.4"><vh>show_derived_files_statistics</vh></v>
<v t="vitalije.20170720214432.5"><vh>paths_data</vh></v>
</v>
<v t="vitalije.20170721075355.1"><vh>valid_files</vh></v>
<v t="vitalije.20170720214432.6"><vh>get_file</vh></v>
<v t="vitalije.20170720214432.7"><vh>get_lines</vh></v>
<v t="vitalije.20170720214432.8"><vh>headline_for_ideal_import</vh></v>
<v t="vitalije.20170720214432.9"><vh>ideal_path_for_import</vh></v>
<v t="vitalije.20170720214432.10"><vh>scan_for_ideal_import</vh></v>
<v t="vitalije.20170720214432.11"><vh>try_import_file</vh></v>
<v t="vitalije.20170720214432.12"><vh>clear gnxDict</vh></v>
<v t="vitalije.20170720214432.13"><vh>can_import_every_derived_file</vh></v>
<v t="vitalije.20170720214432.14"><vh>test_1</vh></v>
</v>
<v t="ekr.20170719102447.28"><vh>Read</vh>
<v t="vitalije.20170721090105.1"><vh>patterns</vh></v>
<v t="vitalije.20170721184930.1"><vh>get_patterns</vh></v>
<v t="ekr.20170719102447.29"><vh>node_start_lines</vh>
<v t="ekr.20170719102447.30"><vh>at_node_start</vh></v>
</v>
<v t="vitalije.20170721090017.1"><vh>sect_refs</vh>
<v t="vitalije.20170721090011.1"><vh>at_sect_ref</vh></v>
</v>
<v t="ekr.20170719102447.32"><vh>at_others_refs</vh>
<v t="vitalije.20170721091325.1"><vh>match_at_others</vh></v>
</v>
<v t="vitalije.20170721095723.1"><vh>at_all_refs</vh>
<v t="vitalije.20170721095723.3"><vh>match_at_all</vh></v>
</v>
<v t="vitalije.20170721193719.1"><vh>body lines ...</vh>
<v t="ekr.20170719102447.37"><vh>body_lines_of_top_node</vh></v>
<v t="ekr.20170719102447.33"><vh>body_lines_of_node</vh>
<v t="ekr.20170719102447.34"><vh>body_raw_lines_of_node</vh>
<v t="vitalije.20170721192544.1"><vh>if in verbatims</vh></v>
<v t="vitalije.20170721192602.1"><vh>elif at verbatim sentinel</vh></v>
<v t="vitalije.20170721192639.1"><vh>elif at-all starts</vh></v>
<v t="vitalije.20170721192649.1"><vh>elif at-others starts</vh></v>
<v t="vitalije.20170721192800.1"><vh>elif section starts</vh></v>
<v t="vitalije.20170721192809.1"><vh>elif node starts</vh></v>
<v t="vitalije.20170721192819.1"><vh>elif at-others end</vh></v>
<v t="vitalije.20170721192855.1"><vh>else ordinary line</vh></v>
</v>
<v t="ekr.20170719102447.35"><vh>check_at_doc</vh></v>
<v t="ekr.20170719102447.36"><vh>check_at_code</vh></v>
<v t="vitalije.20170721131019.1"><vh>strip_end_delimiter</vh></v>
</v>
</v>
<v t="ekr.20170719102447.38"><vh>end_of_node</vh>
<v t="vitalije.20170721180227.1"><vh>end_of_node_in_all</vh></v>
<v t="vitalije.20170721180649.1"><vh>end_of_node_in_others</vh></v>
</v>
<v t="ekr.20170719102447.39"><vh>analyze_lines</vh>
<v t="vitalije.20170721194006.1"><vh>header of derived file</vh></v>
<v t="vitalije.20170721194026.1"><vh>verbatims</vh></v>
<v t="vitalije.20170721194127.1"><vh>data for further analysis</vh></v>
<v t="vitalije.20170721194142.1"><vh>at_all data</vh></v>
<v t="vitalije.20170721194157.1"><vh>nodes data</vh></v>
<v t="vitalije.20170721194206.1"><vh>sections data</vh></v>
<v t="vitalije.20170721194213.1"><vh>at_others data</vh></v>
</v>
<v t="vitalije.20170721100524.1"><vh>find_all</vh></v>
<v t="vitalije.20170721100518.1"><vh>read_verbatims</vh></v>
<v t="ekr.20170719102447.40"><vh>children_gnxes</vh></v>
<v t="ekr.20170719102447.41"><vh>gnx2headline</vh></v>
<v t="ekr.20170719102447.42"><vh>read_at_first_lines</vh></v>
<v t="vitalije.20170721173437.1"><vh>read_at_last_lines</vh></v>
<v t="vitalije.20170721083818.1"><vh>read_header</vh></v>
</v>
<v t="ekr.20170719102447.10"><vh>Write</vh>
<v t="ekr.20170719102447.11"><vh>starting_pos</vh></v>
<v t="ekr.20170719102447.12"><vh>add_ident</vh></v>
<v t="ekr.20170719102447.13"><vh>cut_left</vh></v>
<v t="ekr.20170719102447.14"><vh>cut_right</vh></v>
<v t="ekr.20170719102447.15"><vh>section_ref</vh></v>
<v t="ekr.20170719102447.16"><vh>before_double_gt</vh></v>
<v t="ekr.20170719102447.17"><vh>after_str</vh></v>
<v t="ekr.20170719102447.18"><vh>MissingSection</vh></v>
<v t="ekr.20170719102447.19"><vh>others_iterator</vh></v>
<v t="ekr.20170719102447.20"><vh>section_replacer</vh></v>
<v t="ekr.20170719102447.21"><vh>body_lines</vh></v>
<v t="ekr.20170719102447.22"><vh>others_replacer</vh></v>
<v t="ekr.20170719102447.23"><vh>all_lines</vh></v>
<v t="ekr.20170719102447.24"><vh>at_docer</vh></v>
<v t="ekr.20170719102447.25"><vh>at_adder</vh></v>
<v t="ekr.20170719102447.26"><vh>star_level</vh></v>
<v t="ekr.20170719102447.27"><vh>node_opener</vh></v>
</v>
<v t="vitalije.20170720181053.1"><vh>patch VNode</vh>
<v t="vitalije.20170720181045.1"><vh>vnode_get_lines</vh></v>
<v t="vitalije.20170720190022.1"><vh>total_lines</vh></v>
<v t="vitalije.20170720190205.1"><vh>has_others</vh></v>
<v t="vitalije.20170720182924.1"><vh>one_line_directives</vh></v>
<v t="vitalije.20170720192016.1"><vh>vnode_how_many_from_this_line</vh></v>
<v t="vitalije.20170720194135.1"><vh>vnode_f_lines</vh></v>
</v>
</v>
<v t="vitalije.20170721074430.1"><vh>exp-4 dev @key=Alt-4</vh>
<v t="vitalije.20170721075016.1"><vh>cloned</vh>
<v t="vitalije.20170720214432.1"></v>
<v t="vitalije.20170721190334.1"><vh>Utils</vh>
<v t="vitalije.20170721174314.1"><vh>indent</vh></v>
</v>
<v t="ekr.20170719102447.28"></v>
<v t="ekr.20170719102447.10"></v>
</v>
<v t="vitalije.20170721075007.1"><vh>run_experiment</vh></v>
<v t="vitalije.20170721201600.1"><vh>compare_reading_file</vh></v>
<v t="vitalije.20170721201605.1"><vh>compare_reading_all_files</vh></v>
</v>
<v t="vitalije.20170720214636.1"><vh>EXTERNALS</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20170719102447.10"></t>
<t tx="ekr.20170719102447.11">def starting_pos():
    pi = c.find_h('@file leoGlobals.py') [0]
    return pi</t>
<t tx="ekr.20170719102447.12">def add_ident(n, it):
    wsp = ' '*n
    for w in it:
        yield wsp
        yield w</t>
<t tx="ekr.20170719102447.13">def cut_left(n, it):
    for w in it:
        yield w[n:]</t>
<t tx="ekr.20170719102447.14">def cut_right(n, it):
    for w in it:
        yield w[:n]</t>
<t tx="ekr.20170719102447.15">def section_ref(s):
    i = s.find('&lt;&lt;')
    j = s.find('&gt;&gt;')
    if -1 &lt; i &lt; j:
        s1 = s[i:j+2]
        if s1.startswith('&lt;&lt;&lt;') or g.match(s, j+2, '&gt;'):
            g.es('dubious brackets in', s)
    else:
        s1 = None
    return s1</t>
<t tx="ekr.20170719102447.16">def before_double_gt(s):
    i = s.find('&lt;&lt;')
    return '' if i &lt; 0 else s[:i]</t>
<t tx="ekr.20170719102447.17">def after_str(s, w):
    n = len(w)
    i = s.find(w)
    return s if i &lt; 0 else s[i+n:]</t>
<t tx="ekr.20170719102447.18">class MissingSection(IndexError):
    pass</t>
<t tx="ekr.20170719102447.19">others_pat = re.compile('^\\s*@others', re.M)

def others_iterator(p):
    after = p.nodeAfterTree()
    p1 = p.copy().moveToThreadNext()
    while p1 and p1 != after:
        if p1.isAtIgnoreNode() or section_ref(p1.h):
            p1.moveToNodeAfterTree()
        else:
            yield p1.copy()
            if others_pat.search(p1.b):
                p1.moveToNodeAfterTree()
            else:
                p1.moveToThreadNext()
</t>
<t tx="ekr.20170719102447.20">def section_replacer(it, zero_level):
    for p, w in it:
        sref = section_ref(w)
        if sref:
            indent = before_double_gt(w)
            yield None, indent
            p1 = g.findReference(sref, p)
            if not p1:
                raise MissingSection(w)
            yield None, '#@+'
            yield None, sref
            yield None, '\n'
            for junk, w1 in all_lines(p1, zero_level):
                yield None, indent
                yield None, w1
            yield None, indent
            yield None, '#@-'
            yield None, sref
            yield None, after_str(w, sref)
        else:
            yield p, w
</t>
<t tx="ekr.20170719102447.21">def body_lines(p):
    if p.b:
        for line in g.splitLines(p.b):
            yield p, line
        if not line.endswith('\n'):
            yield p, '\n'
    else:
        yield p, ''</t>
<t tx="ekr.20170719102447.22">def others_replacer(it, zero_level):
    for p, w in it:
        i = g.skip_ws(w, 0)
        if p and g.match(w, i, '@others'):
            indent = w[:i]
            yield p, indent
            yield None, '#@+others\n'
            for p1 in others_iterator(p):
                for p2, w2 in all_lines(p1, zero_level):
                    yield None, indent
                    yield None, w2
            yield None, indent
            yield None, '#@-others\n'
        else:
            yield p, w</t>
<t tx="ekr.20170719102447.23">def all_lines(p, zero_level):
    it = body_lines(p)
    it = section_replacer(it, zero_level)
    it = others_replacer(it, zero_level)
    it = node_opener(it, zero_level)
    it = at_adder(it)
    it = at_docer(it)
    return it
</t>
<t tx="ekr.20170719102447.24">def at_docer(it):
    in_doc = False
    for p, w in it:
        if w[1:2].isspace() and g.match(w, 0, '@'):
            in_doc = True
            yield None, '#@+at'
            yield None, w[1:]
            continue
        if w[:2] == '@c' and w[2:3].isspace():
            yield p, w
            in_doc = False
            continue
        if w.startswith('@code') and w[5:6].isspace():
            in_doc = False
            yield p, w
            continue
        if in_doc and w != '#@':
            yield None, '# '
            yield p, w
        else:
            yield p, w</t>
<t tx="ekr.20170719102447.25">atdir_pat = re.compile('^@(code|c\\s|doc|nobeautify|first|last|language|tabwidth|pagewidth)')

def at_adder(it):
    for p, w in it:
        m = atdir_pat.match(w)
        if p and m:
            yield None, '#@'
            if m.group(1) in ('first', 'last'):
                yield None, '@'
                yield None, m.group(1)
                yield None, '\n'
            else:
                yield None, w
        else:
            yield p, w</t>
<t tx="ekr.20170719102447.26">def star_level(lev):
    if lev &lt; 2:
        return [': * ', ': ** '][lev]
    else:
        return ': *%d* '%(lev + 1)</t>
<t tx="ekr.20170719102447.27">def node_opener(it, zero_level):
    prev_pos = None
    for p, w in it:
        if p is None or p == prev_pos:
            yield p, w
        else:
            prev_pos = p
            yield None, '#@+node:'
            yield None, p.gnx
            yield None, star_level(p.level() - zero_level)
            yield None, p.h
            yield None, '\n'
            yield p, w</t>
<t tx="ekr.20170719102447.28"></t>
<t tx="ekr.20170719102447.29">def node_start_lines(data):
    flines, ptrns, verbatims = data
    pat = ptrns.node_start

    for i, line in flines:
        if i in verbatims: continue

        m = at_node_start(i, line, pat)
        if m:
            yield m
</t>
<t tx="ekr.20170719102447.30">def at_node_start(i, line, pat):
    m = pat.match(line)
    if m:
        if m.group(3):
            level = int(m.group(3)) #levelNo
        elif m.group(4): #second_star
            level = 2
        else:
            level = 1
        return (i, # line no
                m.group(1), #indent
                m.group(2), #gnx
                level,
                m.group(5)) #headline
    else:
        return False</t>
<t tx="ekr.20170719102447.32">def at_others_refs(data):
    flines, ptrns, verbatims = data
    pat = ptrns.others
    starts = []

    for i, line in flines:

        if i in verbatims: continue

        m = match_at_others(i, line, pat)

        if m and m[2]:
            starts.append(m)
        elif m:
            j, indent, junk = starts.pop()
            yield j, i, indent

</t>
<t tx="ekr.20170719102447.33">def body_lines_of_node(gnx, analytics):
    a = analytics; delim_st = a.delim_st

    in_doc = False

    for line in body_raw_lines_of_node(gnx, analytics):

        atdoc, line = check_at_doc(line, delim_st)
        if atdoc:
            yield line
            in_doc = True
            continue

        atcode, line = check_at_code(line, delim_st)
        if atcode:
            yield line
            in_doc = False
            continue

        if in_doc:
            if not line.startswith(delim_st):
                yield line
            else:
                yield line[len(delim_st)+1:]
        else:
            yield line
</t>
<t tx="ekr.20170719102447.34">def body_raw_lines_of_node(gnx, analytics):
    a = analytics; flines = a.flines; verbatims = a.verbatims
    st, lev, h, ind = a.nodes[gnx][0]
    node_end = end_of_node(gnx, analytics)
    i  = st + 1 # line after at+node
    # is node inside at-all directive?
    all_ij= find_all(i, a.atall)

    while i &lt; node_end:
        @others
</t>
<t tx="ekr.20170719102447.35">def check_at_doc(line, delim_st):
    if line.startswith(delim_st):
        rl = line[len(delim_st):]
        if rl.startswith(('@+at\n', '@+at ')):
            return True, '@' + rl[4:]
        elif rl.startswith(('@+doc ', '@+doc\n')):
            return True, '@' + rl[2:]
    return False, line</t>
<t tx="ekr.20170719102447.36">def check_at_code(line, delim_st):
    if line.startswith(delim_st):
        rl = line[len(delim_st):]
        if rl.startswith(('@@c\n', '@@code\n')):
            return True, rl[1:]
        elif rl.startswith('@@'):
            return False, strip_end_delimiter(rl[1:], delim_st)
    return False, line

</t>
<t tx="ekr.20170719102447.37">def body_lines_of_top_node(gnx, analytics):
    a = analytics; delim_st = a.delim_st

    first_lines = list(read_at_first_lines(analytics))
    last_lines = list(read_at_last_lines(analytics))

    leo_end = delim_st + '@-leo'

    for line in body_lines_of_node(gnx, analytics):
        if line.startswith(leo_end):
            continue # skip end of file sentinel
        elif line.startswith('@first'):
            assert first_lines, repr(first_lines)
            # insert first line
            yield line[:6] + ' ' + first_lines.pop(0)
        elif line.startswith('@last'):
            assert last_lines, repr(last_lines)
            # insert last line
            yield line[:5] + ' ' + last_lines.pop(0)
        else:
            yield line</t>
<t tx="ekr.20170719102447.38">def end_of_node(gnx, analytics):

    a = analytics

    st, lev, h, ind = a.nodes[gnx][0]

    is_inside = lambda x:st &gt; x[0] and st &lt; x[1]
    in_all = next(filter(is_inside, a.atall),  False)

    if in_all:
        end_all = in_all[1]
        res = end_of_node_in_all(st, end_all, analytics)

    elif st - 1 in a.sects:
        # inside section node: end is at the end of section
        res = a.sects[st-1][0]

    else:
        # not in all, not in section
        # must be in at-others
        res = end_of_node_in_others(st, lev, analytics)

    return res
</t>
<t tx="ekr.20170719102447.39">def analyze_lines(lines):
    flines = tuple(enumerate(lines))
    @others
    return g.bunch(
            flines = flines,
            nodes = node_data,
            nstart = node_starts,
            sects = sect_data,
            othrs = at_oth_data,
            oend = oth_ends,
            delim_st = delim_st,
            delim_en = delim_en,
            verbatims = verbatims,
            atall = at_all_data,)

</t>
<t tx="ekr.20170719102447.40">def children_gnxes(gnx, analytics):
    a = analytics; node_data = a.nodes
    st, level, h, wsp = node_data.get(gnx)[0]
    i = st + 1 # start after at+node sentinel
    tlevel = level + 1 # target level we are looking for
    while i &lt; len(flines):
        ignx = a.nstart.get(i)
        if ignx:
            ilev = node_data.get(ignx)[0][1]
            if ilev == tlevel:
                yield ignx
            elif ilev &lt; tlevel:
                break
        i += 1</t>
<t tx="ekr.20170719102447.41">def gnx2headline(gnx, analytics):
    a = analytics
    return a.nodes[gnx][0][2]</t>
<t tx="ekr.20170719102447.42">def read_at_first_lines(analytics):
    a = analytics
    for i, line in a.flines:
        if leo_header_pat.match(line):
            # first lines are only before at+leo
            break
        yield line
</t>
<t tx="vitalije.20170720180020.1">import itertools
import re
import leo.core.leoNodes as leoNodes
c.frame.log.selectTab('Log')
c.frame.log.clearLog()
@others
p = c.find_h('EXTERNALS')[0]
if not p.hasChildren():
    do_import_file(149)
    c.redraw()
p.moveToFirstChild()
import timeit
def test_lines_enumerator():
    n = f_line_numerate(p.copy(), 1, True)
num = 100
t = timeit.timeit(test_lines_enumerator, number=num)
g.es(t/num, 'seconds')

with_sentinels = p.h.startswith(('@file ', '@thin '))
try:
    n = f_line_numerate(p, 1, with_sentinels)
except Exception as e:
    g.es_exception(e)
    g.traceback.print_exc()
g.es('enumerated last line', n)
to_display = ['ekr.20031218072017.2608',
              'ekr.20120219194520.10463',
              'ekr.20161026122804.1',
              'ekr.20161026125611.1',
              'ekr.20161026124810.1',
              'ekr.20120209051836.10241',
              'ekr.20031218072017.1416',
              'ekr.20161028035755.1',
              'ekr.20050424131051',
              'ekr.20150514125218.5'
              ]
for gnx in to_display:
    v = c.fileCommands.gnxDict[gnx]
    g.es(v.h)
    for n, line in zip(v.f_lines, v.lines):
        if line == v.lines[0] or line == v.lines[-1]:
            g.es('---', n, line.rstrip())
        </t>
<t tx="vitalije.20170720181045.1">def vnode_get_lines(v):
    if hasattr(v,'_prevBody') and v._prevBody == v._bodyString:
        return v._lines
    else:
        v._prevBody = v._bodyString
        v._lines = tuple(g.splitLines(v._bodyString))
    return v._lines
leoNodes.VNode.lines = property(vnode_get_lines)</t>
<t tx="vitalije.20170720181053.1">def f_line_numerate(p, start=1, with_sentinels=True):
    f_lines = []
    n = start; check_first = start == 1
    inc = lambda x:x + 1 if with_sentinels else x
    nf = 0
    if start &gt; 1:
        n = inc(n)
    for line in p.v.lines:
        if check_first and line.startswith('@first '):
            f_lines.append(n)
            n += 1
            nf += 1
            continue
        if check_first and with_sentinels:
            n += 2 + nf
        check_first = False
        f_lines.append(n)
        sref = section_ref(line)
        if sref:
            p1 = g.findReference(sref, p)
            if not p1:
                raise MissingSection(line)
            n = inc(n)
            n = f_line_numerate(p1, n, with_sentinels)
            n = inc(n)
            continue
        if others_pat.match(line):
            n = inc(n)
            for p1 in others_iterator(p):
                n = f_line_numerate(p1, n, with_sentinels)
            n = inc(n)
            continue
        if with_sentinels or not g.isDirective(line):
            n += 1
    p.v.f_lines = tuple(f_lines)
    return inc(n) if start==1 else n
</t>
<t tx="vitalije.20170720182924.1">one_line_directives = '''
beautify colorcache code color comment c delims doc encoding end_raw first
header ignore killbeautify killcolor language last lineending markup
nobeautify nocolor-node nocolor noheader nowrap nosearch pagewidth path raw
quiet root-code root-doc root silent tabwidth unit terse verbose wrap'''.split()
one_line_directives = tuple('@'+x for x in one_line_directives)</t>
<t tx="vitalije.20170720190022.1">def vnode_total_lines(p, with_sentinels=True):
    n = 0
    for line in p.v.lines:
        n += vnode_how_many_from_this_line(p, line, with_sentinels)
    return n
</t>
<t tx="vitalije.20170720190205.1">def vnode_has_others(v):
    for x in v.lines:
        if others_pat.match(x):
            return True
    else:
        return False
leoNodes.VNode.has_others = property(vnode_has_others)
</t>
<t tx="vitalije.20170720192016.1">def vnode_how_many_from_this_line(p, line, with_sentinels=True):
    sref = section_ref(line)
    if sref:
        p1 = g.findReference(sref, p)
        if not p1:
            raise MissingSection(sref)
        return 2 + vnode_total_lines(p1, with_sentinels)
    elif others_pat.match(line):
        n = 2
        for p1 in others_iterator(p):
            n += vnode_total_lines(p1, with_sentinels)
    elif g.isDirective(line) and not with_sentinels:
        return 0
    else:
        return 1</t>
<t tx="vitalije.20170720194135.1">def vnode_f_lines(p, start=0, with_sentinels=True):
    if with_sentinels:
        return vnode_f_lines_with_sentinels(p, start)
    n = start
    for i, line in enumerate(p.v.lines):
        yield n
        n += vnode_how_many_from_this_line(p, line, False)

def vnode_f_lines_with_sentinels(p, start):
    n = start + 1
    first = 1
    for i, line in enumerate(p.v.lines):
        if line.startswith('@first '):
            yield first
            first += 1
            n += 1
        else:
            yield n
            n += vnode_how_many_for_this_line(p, line, True)</t>
<t tx="vitalije.20170720214432.1"></t>
<t tx="vitalije.20170720214432.10">def scan_for_ideal_import():
    res = {}
    for j,fn in enumerate(derived_files):
        if j in false_positives: continue
        pfi = path_for_ideal_import(j)
        assert pfi.startswith(('@file ', '@thin '))
        assert fn.startswith(g.app.leoDir)
        fn = fn[len(g.app.leoDir)-3:]
        res[fn] = pfi[6:].strip()
    return res</t>
<t tx="vitalije.20170720214432.11">def try_import_file(j):
    if j in false_positives: return True
    ok = False
    try:
        result = do_import_file(j)
        if result:
            ok, p2 = result
        else:
            ok, p2 = False, None
    finally:
        if p2:
            p2.doDelete()
    return ok
def do_import_file(j):
    p1 = c.find_h('EXTERNALS')[0]
    p2 = p1.insertAsLastChild()
    fn = derived_files[j]
    p1.b = '@path %s'%ideal_path_for_import(j)
    hfi = headline_for_ideal_import(j)
    p2.h = hfi
    gnx = p2.gnx
    pth = c.getNodeFileName(p2)
    fn2 = fn.replace('/', '\\')
    assert pth in (fn, fn2), '%d \n%s !=\n%s\n%s'%(j, pth, fn, hfi)
    ok = c.atFileCommands.read(p2, force=True)
    gnx2 = p2.gnx
    if gnx != gnx2:
        c.fileCommands.gnxDict[gnx2] = p2.v
        c.fileCommands.gnxDict.pop(gnx)
    p2.contract()
    return ok,p2</t>
<t tx="vitalije.20170720214432.12">def clear_gnxDict():
    valid_gnxes = set(v.gnx for v in c.all_unique_nodes())
    all_gnxes = set(x for x in c.fileCommands.gnxDict.keys())
    invalid = all_gnxes.difference(valid_gnxes)
    # g.es(len(valid_gnxes), len(all_gnxes), len(invalid))
    for gnx in invalid:
        c.fileCommands.gnxDict.pop(gnx)


</t>
<t tx="vitalije.20170720214432.13">def can_import_every_derived_file():
    errs = set()
    try:
        log = g.app.log
        g.unitTesting = True
        for i in range(len(derived_files)):
            ok = try_import_file(i)
            s = '.' if ok else 'E'
            if i % 35 == 34:
                log.put(s + '\n')
            else:
                log.put(s)
            if ok: continue
            errs.add(i)
    finally:
        g.unitTesting = False
        g.es('\n')
    clear_gnxDict()
    if errs:
        g.es(errs)
    return not errs</t>
<t tx="vitalije.20170720214432.14">def test_1():
    if can_import_every_derived_file():
        g.es('ok')
    else:
        g.es("some files can't be imported\nSee log.")</t>
<t tx="vitalije.20170720214432.2">derived_files = ('''%(leo)s/doc/leoProjects.txt
%(leo)s/doc/leoAttic.txt
%(leo)s/doc/release_notes.txt
%(leo)s/doc/leoUserGuide.txt
%(leo)s/doc/leoBridge.txt
%(leo)s/doc/zodb.txt
%(leo)s/doc/running.txt
%(leo)s/doc/slideshows.txt
%(leo)s/doc/leoandotherprograms.txt
%(leo)s/doc/testimonials.txt
%(leo)s/doc/leoToDo.txt
%(leo)s/doc/vimBindings.txt
%(leo)s/doc/usersguide.txt
%(leo)s/doc/whatsnew.txt
%(leo)s/doc/slides.txt
%(leo)s/doc/rstplugin3.txt
%(leo)s/doc/debuggers.txt
%(leo)s/doc/customizing.txt
%(leo)s/doc/LeoDocs.leo
%(leo)s/doc/appendices.txt
%(leo)s/doc/unitTesting.txt
%(leo)s/doc/LeoReleaseNotes.leo
%(leo)s/doc/leoToDoLater.txt
%(leo)s/doc/nutshell.txt
%(leo)s/doc/design.txt
%(leo)s/doc/cheatsheet.txt
%(leo)s/doc/preface.txt
%(leo)s/doc/outline-commands.txt
%(leo)s/doc/leoSlideShows.leo
%(leo)s/doc/intermediatetopics.txt
%(leo)s/doc/preliminaries.txt
%(leo)s/doc/download.txt
%(leo)s/doc/leoNotes.txt
%(leo)s/doc/FAQ.txt
%(leo)s/doc/html/index.html
%(leo)s/doc/frontMatter.txt
%(leo)s/doc/glossary.txt
%(leo)s/doc/atShadow.txt
%(leo)s/doc/plugin_catalog.py
%(leo)s/doc/coloring.txt
%(leo)s/doc/intro.txt
%(leo)s/doc/screen-shots.txt
%(leo)s/doc/plugins.txt
%(leo)s/doc/outlines.txt
%(leo)s/doc/commands.txt
%(leo)s/doc/IpythonBridge.txt
%(leo)s/doc/emacs.txt
%(leo)s/doc/sphinx-docs/leo.rst
%(leo)s/doc/sphinx-docs/index.rst
%(leo)s/doc/sphinx-docs/requirements.txt
%(leo)s/doc/sphinx-docs/leo.plugins.pygeotag.rst
%(leo)s/doc/sphinx-docs/leo.plugins.rst
%(leo)s/doc/sphinx-docs/leo.external.rst
%(leo)s/doc/sphinx-docs/leo.external.concurrent.rst
%(leo)s/doc/sphinx-docs/Makefile
%(leo)s/doc/sphinx-docs/make.bat
%(leo)s/doc/sphinx-docs/leo.core.rst
%(leo)s/doc/sphinx-docs/leo.external.concurrent.futures.rst
%(leo)s/doc/sphinx-docs/conf.py
%(leo)s/doc/sphinx-docs/leo.extensions.rst
%(leo)s/doc/tutorial.txt
%(leo)s/doc/writingPlugins.txt
%(leo)s/doc/installing.txt
%(leo)s/scripts/build-leo.bat
%(leo)s/scripts/tangle_done.py
%(leo)s/scripts/unregister-leo.leox
%(leo)s/scripts/register-leo.leox
%(leo)s/scripts/elevate.py
%(leo)s/scripts/gen_blender_docs.py
%(leo)s/scripts/leoScripts.txt
%(leo)s/scripts/untangle_done.py
%(leo)s/scripts/leoFindScript.py
%(leo)s/external/obsolete/ipy_leo.py
%(leo)s/external/lproto.py
%(leo)s/external/npyscreen/npysNPSFilteredData.py
%(leo)s/external/npyscreen/wgboxwidget.py
%(leo)s/external/npyscreen/proto_fm_screen_area.py
%(leo)s/external/npyscreen/wgeditmultiline.py
%(leo)s/external/npyscreen/wgtexttokens.py
%(leo)s/external/npyscreen/npyssafewrapper.py
%(leo)s/external/npyscreen/wgtextbox_controlchrs.py
%(leo)s/external/npyscreen/npysThemes.py
%(leo)s/external/npyscreen/apNPSApplication.py
%(leo)s/external/npyscreen/wgwidget_proto.py
%(leo)s/external/npyscreen/wgautocomplete.py
%(leo)s/external/npyscreen/wgtextbox.py
%(leo)s/external/npyscreen/apNPSApplicationManaged.py
%(leo)s/external/npyscreen/wgNMenuDisplay.py
%(leo)s/external/npyscreen/wgpassword.py
%(leo)s/external/npyscreen/fmFormMultiPage.py
%(leo)s/external/npyscreen/globals.py
%(leo)s/external/npyscreen/wgmultilinetreeselectable.py
%(leo)s/external/npyscreen/wggridcoltitles.py
%(leo)s/external/npyscreen/apNPSApplicationEvents.py
%(leo)s/external/npyscreen/eveventhandler.py
%(leo)s/external/npyscreen/npysTree.py
%(leo)s/external/npyscreen/wgtitlefield.py
%(leo)s/external/npyscreen/npysThemeManagers.py
%(leo)s/external/npyscreen/fm_form_edit_loop.py
%(leo)s/external/npyscreen/__init__.py
%(leo)s/external/npyscreen/fmActionFormV2.py
%(leo)s/external/npyscreen/wgselectone.py
%(leo)s/external/npyscreen/npyspmfuncs.py
%(leo)s/external/npyscreen/fmFormMuttActive.py
%(leo)s/external/npyscreen/wgmonthbox.py
%(leo)s/external/npyscreen/apNPSApplicationAdvanced.py
%(leo)s/external/npyscreen/fmFileSelector.py
%(leo)s/external/npyscreen/wgcombobox.py
%(leo)s/external/npyscreen/wgmultilinetree.py
%(leo)s/external/npyscreen/muMenu.py
%(leo)s/external/npyscreen/utilNotify.py
%(leo)s/external/npyscreen/wgmultilineeditable.py
%(leo)s/external/npyscreen/fmFormMutt.py
%(leo)s/external/npyscreen/wgcheckbox.py
%(leo)s/external/npyscreen/wgwidget.py
%(leo)s/external/npyscreen/wgslider.py
%(leo)s/external/npyscreen/apOptions.py
%(leo)s/external/npyscreen/wgmultiselect.py
%(leo)s/external/npyscreen/fmFormWithMenus.py
%(leo)s/external/npyscreen/muNewMenu.py
%(leo)s/external/npyscreen/wgFormControlCheckbox.py
%(leo)s/external/npyscreen/fmActionForm.py
%(leo)s/external/npyscreen/util_viewhelp.py
%(leo)s/external/npyscreen/wggrid.py
%(leo)s/external/npyscreen/wgfilenamecombo.py
%(leo)s/external/npyscreen/fmPopup.py
%(leo)s/external/npyscreen/wgmultiline.py
%(leo)s/external/npyscreen/wgmultiselecttree.py
%(leo)s/external/npyscreen/wgbutton.py
%(leo)s/external/npyscreen/wgdatecombo.py
%(leo)s/external/npyscreen/wgannotatetextbox.py
%(leo)s/external/npyscreen/npysGlobalOptions.py
%(leo)s/external/npyscreen/wgtextboxunicode.py
%(leo)s/external/npyscreen/stdfmemail.py
%(leo)s/external/npyscreen/fmForm.py
%(leo)s/external/stringlist.py
%(leo)s/external/leosax.py
%(leo)s/external/log_listener.py
%(leo)s/external/sax2db.py
%(leo)s/external/edb.py
%(leo)s/external/py2cs.py
%(leo)s/external/make_stub_files.py
%(leo)s/external/log_broadcast.py
%(leo)s/external/codewise.py
%(leo)s/external/leoSAGlobals.py
%(leo)s/core/format-code.py
%(leo)s/core/leoImport.py
%(leo)s/core/leoPrinting.py
%(leo)s/core/leoBridgeTest.py
%(leo)s/core/leoApp.py
%(leo)s/core/leoUndo.py
%(leo)s/core/leoDynamicTest.py
%(leo)s/core/leoFileCommands.py
%(leo)s/core/leoTangle.py
%(leo)s/core/leoTest.py
%(leo)s/core/leoVim.py
%(leo)s/core/leoQt.py
%(leo)s/core/leoIPython.py
%(leo)s/core/leoCompare.py
%(leo)s/core/leoSessions.py
%(leo)s/core/leoGlobals.py
%(leo)s/core/leoFind.py
%(leo)s/core/leoMenu.py
%(leo)s/core/leoCheck.py
%(leo)s/core/leoGui.py
%(leo)s/core/leoBackground.py
%(leo)s/core/leoPlugins.py
%(leo)s/core/leoAst.py
%(leo)s/core/leoNodes.py
%(leo)s/core/leoCommands.py
%(leo)s/core/leoHistory.py
%(leo)s/core/leoVersion.py
%(leo)s/core/leoPersistence.py
%(leo)s/core/leoConfig.py
%(leo)s/core/leoCache.py
%(leo)s/core/leoRst.py
%(leo)s/core/leoBeautify.py
%(leo)s/core/leoPymacs.py
%(leo)s/core/leoExternalFiles.py
%(leo)s/core/leoChapters.py
%(leo)s/core/leoAtFile.py
%(leo)s/core/leoKeys.py
%(leo)s/core/leoShadow.py
%(leo)s/core/buttons.txt
%(leo)s/core/runLeo.py
%(leo)s/core/leoColorizer.py
%(leo)s/core/test_core.txt
%(leo)s/core/leoBridge.py
%(leo)s/core/key-handling-notes.txt
%(leo)s/core/leoDebugger.py
%(leo)s/core/leoColor.py
%(leo)s/core/leoFrame.py
%(leo)s/core/leoRope.py
%(leo)s/extensions/testExtension.py
%(leo)s/extensions/colors.py
%(leo)s/plugins/mod_speedups.py
%(leo)s/plugins/obsolete/ironPythonGui.py
%(leo)s/plugins/obsolete/gtkGui.py
%(leo)s/plugins/obsolete/gtkDialogs.py
%(leo)s/plugins/obsolete/swing_gui.py
%(leo)s/plugins/obsolete/tkGui.py
%(leo)s/plugins/obsolete/wxGui.py
%(leo)s/plugins/qt_frame.py
%(leo)s/plugins/ctagscompleter.py
%(leo)s/plugins/leomylyn.py
%(leo)s/plugins/ftp.py
%(leo)s/plugins/nodewatch.py
%(leo)s/plugins/nested_splitter.py
%(leo)s/plugins/macros.py
%(leo)s/plugins/livecode.py
%(leo)s/plugins/interact.py
%(leo)s/plugins/multifile.py
%(leo)s/plugins/slideshow.py
%(leo)s/plugins/notebook.py
%(leo)s/plugins/leoPluginNotes.txt
%(leo)s/plugins/sftp.py
%(leo)s/plugins/screenshots.py
%(leo)s/plugins/plugins_menu.py
%(leo)s/plugins/xml_edit.py
%(leo)s/plugins/outline_export.py
%(leo)s/plugins/startfile.py
%(leo)s/plugins/graphcanvas.py
%(leo)s/plugins/scripts_menu.py
%(leo)s/plugins/quicksearch.py
%(leo)s/plugins/viewrendered2.py
%(leo)s/plugins/qt_text.py
%(leo)s/plugins/template_gui.py
%(leo)s/plugins/colorize_headlines.py
%(leo)s/plugins/python_terminal.py
%(leo)s/plugins/stickynotes.py
%(leo)s/plugins/runGtkDialogs.py.txt
%(leo)s/plugins/qt_tree.py
%(leo)s/plugins/demo.py
%(leo)s/plugins/setHomeDirectory.py
%(leo)s/plugins/nodetags.py
%(leo)s/plugins/script_io_to_body.py
%(leo)s/plugins/auto_colorize2_0.py
%(leo)s/plugins/leo_to_rtf.py
%(leo)s/plugins/chapter_hoist.py
%(leo)s/plugins/xemacs.py
%(leo)s/plugins/niceNosent.py
%(leo)s/plugins/word_count.py
%(leo)s/plugins/quickMove.py
%(leo)s/plugins/tomboy_import.py
%(leo)s/plugins/mod_read_dir_outline.py
%(leo)s/plugins/qt_gui.py
%(leo)s/plugins/timestamp.py
%(leo)s/plugins/leomail.py
%(leo)s/plugins/expfolder.py
%(leo)s/plugins/dtest.py
%(leo)s/plugins/xsltWithNodes.py
%(leo)s/plugins/rss.py
%(leo)s/plugins/bzr_qcommands.py
%(leo)s/plugins/leo_interface.py
%(leo)s/plugins/leofeeds.py
%(leo)s/plugins/pluginsNotes.txt
%(leo)s/plugins/at_produce.py
%(leo)s/plugins/leoremote.py
%(leo)s/plugins/mod_scripting.py
%(leo)s/plugins/mod_autosave.py
%(leo)s/plugins/run_nodes.py
%(leo)s/plugins/todo.py
%(leo)s/plugins/markup_inline.py
%(leo)s/plugins/importers/python.py
%(leo)s/plugins/importers/ini.py
%(leo)s/plugins/importers/coffeescript.py
%(leo)s/plugins/importers/typescript.py
%(leo)s/plugins/importers/csharp.py
%(leo)s/plugins/importers/linescanner.py
%(leo)s/plugins/importers/ipynb.py
%(leo)s/plugins/importers/leo_rst.py
%(leo)s/plugins/importers/__init__.py
%(leo)s/plugins/importers/java.py
%(leo)s/plugins/importers/xml.py
%(leo)s/plugins/importers/markdown.py
%(leo)s/plugins/importers/c.py
%(leo)s/plugins/importers/javascript.py
%(leo)s/plugins/importers/dart.py
%(leo)s/plugins/importers/perl.py
%(leo)s/plugins/importers/pascal.py
%(leo)s/plugins/importers/php.py
%(leo)s/plugins/importers/html.py
%(leo)s/plugins/importers/org.py
%(leo)s/plugins/importers/lua.py
%(leo)s/plugins/importers/otl.py
%(leo)s/plugins/importers/elisp.py
%(leo)s/plugins/importers/json.py
%(leo)s/plugins/importers/tcl.py
%(leo)s/plugins/importers/ctext.py
%(leo)s/plugins/mod_timestamp.py
%(leo)s/plugins/gitarchive.py
%(leo)s/plugins/dump_globals.py
%(leo)s/plugins/mod_leo2ascd.txt
%(leo)s/plugins/screencast.py
%(leo)s/plugins/debugger_pudb.py
%(leo)s/plugins/qt_commands.py
%(leo)s/plugins/vnodes-history.py
%(leo)s/plugins/writers/basewriter.py
%(leo)s/plugins/writers/ipynb.py
%(leo)s/plugins/writers/leo_rst.py
%(leo)s/plugins/writers/__init__.py
%(leo)s/plugins/writers/markdown.py
%(leo)s/plugins/writers/dart.py
%(leo)s/plugins/writers/test.py
%(leo)s/plugins/writers/org.py
%(leo)s/plugins/writers/otl.py
%(leo)s/plugins/writers/json.py
%(leo)s/plugins/writers/ctext.py
%(leo)s/plugins/pretty_print.py
%(leo)s/plugins/stickynotes_plus.py
%(leo)s/plugins/viewrendered.py
%(leo)s/plugins/mod_http.py
%(leo)s/plugins/at_view.py
%(leo)s/plugins/trace_gc_plugin.py
%(leo)s/plugins/bookmarks.py
%(leo)s/plugins/projectwizard.py
%(leo)s/plugins/jinjarender.py
%(leo)s/plugins/qtGui.py
%(leo)s/plugins/keys.css
%(leo)s/plugins/read_only_nodes.py
%(leo)s/plugins/pyplot_backend.py
%(leo)s/plugins/pluginsManager.txt
%(leo)s/plugins/rst3.py
%(leo)s/plugins/contextmenu.py
%(leo)s/plugins/import_cisco_config.py
%(leo)s/plugins/cursesGui.py
%(leo)s/plugins/dragdropgoodies.py
%(leo)s/plugins/add_directives.py
%(leo)s/plugins/leocursor.py
%(leo)s/plugins/empty_leo_file.py
%(leo)s/plugins/testRegisterCommand.py
%(leo)s/plugins/datenodes.py
%(leo)s/plugins/bigdash.py
%(leo)s/plugins/qtNotes.txt
%(leo)s/plugins/at_folder.py
%(leo)s/plugins/leoscreen.py
%(leo)s/plugins/backlink.py
%(leo)s/plugins/open_shell.py
%(leo)s/plugins/qt_idle_time.py
%(leo)s/plugins/maximizeNewWindows.py
%(leo)s/plugins/test/failed_import.py
%(leo)s/plugins/test/failed_to_load_plugin.py
%(leo)s/plugins/test/syntax_error_plugin.py
%(leo)s/plugins/test/ekr_test.py
%(leo)s/plugins/trace_tags.py
%(leo)s/plugins/free_layout.py
%(leo)s/plugins/nodeActions.py
%(leo)s/plugins/cursesGui2.py
%(leo)s/plugins/spydershell.py
%(leo)s/plugins/leoOPML.py
%(leo)s/plugins/nodediff.py
%(leo)s/plugins/threadutil.py
%(leo)s/plugins/leo_to_html.py
%(leo)s/plugins/baseNativeTree.py
%(leo)s/plugins/initinclass.py
%(leo)s/plugins/redirect_to_log.py
%(leo)s/plugins/enable_gc.py
%(leo)s/plugins/attrib_edit.py
%(leo)s/plugins/FileActions.py
%(leo)s/plugins/trace_keys.py
%(leo)s/plugins/mime.py
%(leo)s/plugins/wikiview.py
%(leo)s/plugins/bibtex.py
%(leo)s/plugins/mod_leo2ascd.py
%(leo)s/plugins/settings_finder.py
%(leo)s/plugins/systray.py
%(leo)s/plugins/tables.py
%(leo)s/plugins/geotag.py
%(leo)s/plugins/mnplugins.py
%(leo)s/plugins/zenity_file_dialogs.py
%(leo)s/plugins/richtext.py
%(leo)s/plugins/examples/override_classes.py
%(leo)s/plugins/examples/redefine_put.py
%(leo)s/plugins/examples/chinese_menu.py
%(leo)s/plugins/examples/print_cp.py
%(leo)s/plugins/examples/french_fm.py
%(leo)s/plugins/examples/override_commands.py
%(leo)s/plugins/screen_capture.py
%(leo)s/plugins/qt_quickheadlines.py
%(leo)s/plugins/quit_leo.py
%(leo)s/plugins/vim.py
%(leo)s/plugins/codewisecompleter.py
%(leo)s/plugins/nav_qt.py
%(leo)s/plugins/qt_events.py
%(leo)s/plugins/leo_pdf.py
%(leo)s/plugins/textnode.py
%(leo)s/plugins/mod_framesize.py
%(leo)s/plugins/paste_as_headlines.py
%(leo)s/plugins/valuespace.py
%(leo)s/plugins/word_export.py
%(leo)s/plugins/active_path.py
%(leo)s/plugins/lineNumbers.py
%(leo)s/dist/setup.py
%(leo)s/test/inactiveTests.txt
%(leo)s/test/test.leo
%(leo)s/test/activeUnitTests.txt
%(leo)s/test/unittest/at-thin-line-number-test.py
%(leo)s/test/unittest/at-noref-test.py
%(leo)s/test/unittest/batchTest.py
%(leo)s/test/unittest/at-path-test1.py
%(leo)s/test/unittest/at-path-test3.py
%(leo)s/test/unittest/at-path-test2.py
%(leo)s/test/unittest/at-file-line-number-test.py
%(leo)s/test/unittest/at-thin-test.py
%(leo)s/test/unittest/at-thin-html-test.html
%(leo)s/test/unittest/tex-error.tex
%(leo)s/test/unittest/at-file-test.py
%(leo)s/test/unittest/input/cweave.w
%(leo)s/test/unittest/input/testLeoAtFile.py
%(leo)s/test/unittest/at-file-thin-test2.txt
%(leo)s/test/unittest/at-file-line-number-test.c
%(leo)s/test/unittest/errorTest.py
%(leo)s/test/cgi-bin/edward.py
%(leo)s/test/cgi-bin/leo.js
%(leo)s/test/unitTestStartup.txt
%(leo)s/commands/killBufferCommands.py
%(leo)s/commands/baseCommands.py
%(leo)s/commands/convertCommands.py
%(leo)s/commands/abbrevCommands.py
%(leo)s/commands/controlCommands.py
%(leo)s/commands/searchCommands.py
%(leo)s/commands/spellCommands.py
%(leo)s/commands/gotoCommands.py
%(leo)s/commands/checkerCommands.py
%(leo)s/commands/debugCommands.py
%(leo)s/commands/helpCommands.py
%(leo)s/commands/keyCommands.py
%(leo)s/commands/bufferCommands.py
%(leo)s/commands/rectangleCommands.py
%(leo)s/commands/editFileCommands.py
%(leo)s/commands/editCommands.py'''%{'leo': g.app.leoDir}).splitlines(False)</t>
<t tx="vitalije.20170720214432.3">false_positives = frozenset(
    [    3,  18,  21,  28,  64,  70,  71, 135, 138, # 138 is part of sqlite-leo branch
       183, 186, 188, 193, 194, 197, 198, 230, 255, 296, # 296 is vnodes-history.py
       318, 321, 394, 397, 406, 407, 408, 409, 412,
       413])
# 296, 138 are not part of official leo distribution</t>
<t tx="vitalije.20170720214432.4">def show_derived_files_statistics():
    g.es('number of derived files:', len(derived_files))
    all_delims = set()
    all_versions = set()
    all_trailings = set()
    for j,fn in enumerate(derived_files[0:450]):
        if j in false_positives: continue
        lines = get_lines(j)
        for i, line in enumerate(lines):
            m = at_leo_start_pat.match(line)
            if m:
                delim = m.group(1)
                all_delims.add(delim)
                ver = m.group(2)
                all_versions.add(ver.strip())
                tc = m.group(3).strip()
                all_trailings.add(tc)
                break
    g.es('all_delims', all_delims)
    g.es('all_versions', all_versions)
    g.es('all_trailings', all_trailings)</t>
<t tx="vitalije.20170720214432.5">paths_data = {
 'leo/commands/abbrevCommands.py': '../commands/abbrevCommands.py',
 'leo/commands/baseCommands.py': '../commands/baseCommands.py',
 'leo/commands/bufferCommands.py': '../commands/bufferCommands.py',
 'leo/commands/checkerCommands.py': '../commands/checkerCommands.py',
 'leo/commands/controlCommands.py': '../commands/controlCommands.py',
 'leo/commands/convertCommands.py': '../commands/convertCommands.py',
 'leo/commands/debugCommands.py': '../commands/debugCommands.py',
 'leo/commands/editCommands.py': '../commands/editCommands.py',
 'leo/commands/editFileCommands.py': '../commands/editFileCommands.py',
 'leo/commands/gotoCommands.py': '../commands/gotoCommands.py',
 'leo/commands/helpCommands.py': '../commands/helpCommands.py',
 'leo/commands/keyCommands.py': '../commands/keyCommands.py',
 'leo/commands/killBufferCommands.py': '../commands/killBufferCommands.py',
 'leo/commands/rectangleCommands.py': '../commands/rectangleCommands.py',
 'leo/commands/searchCommands.py': '../commands/searchCommands.py',
 'leo/commands/spellCommands.py': '../commands/spellCommands.py',
 'leo/core/format-code.py': 'format-code.py',
 'leo/core/leoApp.py': 'leoApp.py',
 'leo/core/leoAst.py': 'leoAst.py',
 'leo/core/leoAtFile.py': 'leoAtFile.py',
 'leo/core/leoBackground.py': 'leoBackground.py',
 'leo/core/leoBeautify.py': 'leoBeautify.py',
 'leo/core/leoBridge.py': 'leoBridge.py',
 'leo/core/leoBridgeTest.py': 'leoBridgeTest.py',
 'leo/core/leoCache.py': 'leoCache.py',
 'leo/core/leoChapters.py': 'leoChapters.py',
 'leo/core/leoCheck.py': 'leoCheck.py',
 'leo/core/leoColor.py': 'leoColor.py',
 'leo/core/leoColorizer.py': 'leoColorizer.py',
 'leo/core/leoCommands.py': 'leoCommands.py',
 'leo/core/leoCompare.py': 'leoCompare.py',
 'leo/core/leoConfig.py': 'leoConfig.py',
 'leo/core/leoDebugger.py': 'leoDebugger.py',
 'leo/core/leoDynamicTest.py': 'leoDynamicTest.py',
 'leo/core/leoExternalFiles.py': 'leoExternalFiles.py',
 'leo/core/leoFileCommands.py': 'leoFileCommands.py',
 'leo/core/leoFind.py': 'leoFind.py',
 'leo/core/leoFrame.py': 'leoFrame.py',
 'leo/core/leoGlobals.py': 'leoGlobals.py',
 'leo/core/leoGui.py': 'leoGui.py',
 'leo/core/leoHistory.py': 'leoHistory.py',
 'leo/core/leoIPython.py': 'leoIPython.py',
 'leo/core/leoImport.py': 'leoImport.py',
 'leo/core/leoKeys.py': 'leoKeys.py',
 'leo/core/leoMenu.py': 'leoMenu.py',
 'leo/core/leoNodes.py': 'leoNodes.py',
 'leo/core/leoPersistence.py': 'leoPersistence.py',
 'leo/core/leoPlugins.py': 'leoPlugins.py',
 'leo/core/leoPrinting.py': 'leoPrinting.py',
 'leo/core/leoPymacs.py': 'leoPymacs.py',
 'leo/core/leoQt.py': 'leoQt.py',
 'leo/core/leoRope.py': 'leoRope.py',
 'leo/core/leoRst.py': 'leoRst.py',
 'leo/core/leoSessions.py': 'leoSessions.py',
 'leo/core/leoShadow.py': 'leoShadow.py',
 'leo/core/leoTangle.py': 'leoTangle.py',
 'leo/core/leoTest.py': 'leoTest.py',
 'leo/core/leoUndo.py': 'leoUndo.py',
 'leo/core/leoVersion.py': 'leoVersion.py',
 'leo/core/leoVim.py': 'leoVim.py',
 'leo/core/runLeo.py': 'runLeo.py',
 'leo/dist/setup.py': '../../setup.py',
 'leo/doc/FAQ.txt': 'FAQ.txt',
 'leo/doc/IpythonBridge.txt': 'IpythonBridge.txt',
 'leo/doc/appendices.txt': 'appendices.txt',
 'leo/doc/atShadow.txt': 'atShadow.txt',
 'leo/doc/cheatsheet.txt': 'cheatsheet.txt',
 'leo/doc/coloring.txt': 'coloring.txt',
 'leo/doc/commands.txt': 'commands.txt',
 'leo/doc/customizing.txt': 'customizing.txt',
 'leo/doc/debuggers.txt': 'debuggers.txt',
 'leo/doc/design.txt': 'design.txt',
 'leo/doc/download.txt': 'download.txt',
 'leo/doc/emacs.txt': 'emacs.txt',
 'leo/doc/frontMatter.txt': 'frontMatter.txt',
 'leo/doc/glossary.txt': 'glossary.txt',
 'leo/doc/html/index.html': 'html/index.html--&gt;',
 'leo/doc/installing.txt': 'installing.txt',
 'leo/doc/intermediatetopics.txt': 'intermediatetopics.txt',
 'leo/doc/intro.txt': 'intro.txt',
 'leo/doc/leoAttic.txt': '../doc/leoAttic.txt',
 'leo/doc/leoBridge.txt': 'leoBridge.txt',
 'leo/doc/leoNotes.txt': '../doc/leoNotes.txt',
 'leo/doc/leoProjects.txt': '../doc/leoProjects.txt',
 'leo/doc/leoToDo.txt': '../doc/leoToDo.txt',
 'leo/doc/leoToDoLater.txt': '../doc/leoToDoLater.txt',
 'leo/doc/leoandotherprograms.txt': 'leoandotherprograms.txt',
 'leo/doc/nutshell.txt': 'nutshell.txt',
 'leo/doc/outline-commands.txt': 'outline-commands.txt',
 'leo/doc/outlines.txt': 'outlines.txt',
 'leo/doc/plugin_catalog.py': 'plugin_catalog.py',
 'leo/doc/plugins.txt': 'plugins.txt',
 'leo/doc/preface.txt': 'preface.txt',
 'leo/doc/preliminaries.txt': 'preliminaries.txt',
 'leo/doc/release_notes.txt': 'release_notes.txt',
 'leo/doc/rstplugin3.txt': 'rstplugin3.txt',
 'leo/doc/running.txt': 'running.txt',
 'leo/doc/screen-shots.txt': 'screen-shots.txt',
 'leo/doc/slides.txt': 'slides.txt',
 'leo/doc/slideshows.txt': 'slideshows.txt',
 'leo/doc/sphinx-docs/Makefile': 'Makefile',
 'leo/doc/sphinx-docs/conf.py': 'conf.py',
 'leo/doc/sphinx-docs/index.rst': 'index.rst',
 'leo/doc/sphinx-docs/leo.core.rst': 'leo.core.rst',
 'leo/doc/sphinx-docs/leo.extensions.rst': 'leo.extensions.rst',
 'leo/doc/sphinx-docs/leo.external.concurrent.futures.rst': 'leo.external.concurrent.futures.rst',
 'leo/doc/sphinx-docs/leo.external.concurrent.rst': 'leo.external.concurrent.rst',
 'leo/doc/sphinx-docs/leo.external.rst': 'leo.external.rst',
 'leo/doc/sphinx-docs/leo.plugins.pygeotag.rst': 'leo.plugins.pygeotag.rst',
 'leo/doc/sphinx-docs/leo.plugins.rst': 'leo.plugins.rst',
 'leo/doc/sphinx-docs/leo.rst': 'leo.rst',
 'leo/doc/sphinx-docs/make.bat': 'make.bat',
 'leo/doc/sphinx-docs/requirements.txt': 'requirements.txt',
 'leo/doc/testimonials.txt': 'testimonials.txt',
 'leo/doc/tutorial.txt': 'tutorial.txt',
 'leo/doc/unitTesting.txt': 'unitTesting.txt',
 'leo/doc/usersguide.txt': 'usersguide.txt',
 'leo/doc/vimBindings.txt': 'vimBindings.txt',
 'leo/doc/whatsnew.txt': 'whatsnew.txt',
 'leo/doc/writingPlugins.txt': 'writingPlugins.txt',
 'leo/doc/zodb.txt': 'zodb.txt',
 'leo/external/codewise.py': '../external/codewise.py',
 'leo/external/edb.py': '../external/edb.py',
 'leo/external/leoSAGlobals.py': '../external/leoSAGlobals.py',
 'leo/external/leosax.py': '../external/leosax.py',
 'leo/external/log_broadcast.py': '../external/log_broadcast.py',
 'leo/external/log_listener.py': '../external/log_listener.py',
 'leo/external/lproto.py': '../external/lproto.py',
 'leo/external/make_stub_files.py': '../external/make_stub_files.py',
 'leo/external/npyscreen/__init__.py': '../external/npyscreen/__init__.py',
 'leo/external/npyscreen/apNPSApplication.py': '../external/npyscreen/apNPSApplication.py',
 'leo/external/npyscreen/apNPSApplicationAdvanced.py': '../external/npyscreen/apNPSApplicationAdvanced.py',
 'leo/external/npyscreen/apNPSApplicationEvents.py': '../external/npyscreen/apNPSApplicationEvents.py',
 'leo/external/npyscreen/apNPSApplicationManaged.py': '../external/npyscreen/apNPSApplicationManaged.py',
 'leo/external/npyscreen/apOptions.py': '../external/npyscreen/apOptions.py',
 'leo/external/npyscreen/eveventhandler.py': '../external/npyscreen/eveventhandler.py',
 'leo/external/npyscreen/fmActionForm.py': '../external/npyscreen/fmActionForm.py',
 'leo/external/npyscreen/fmActionFormV2.py': '../external/npyscreen/fmActionFormV2.py',
 'leo/external/npyscreen/fmFileSelector.py': '../external/npyscreen/fmFileSelector.py',
 'leo/external/npyscreen/fmForm.py': '../external/npyscreen/fmForm.py',
 'leo/external/npyscreen/fmFormMultiPage.py': '../external/npyscreen/fmFormMultiPage.py',
 'leo/external/npyscreen/fmFormMutt.py': '../external/npyscreen/fmFormMutt.py',
 'leo/external/npyscreen/fmFormMuttActive.py': '../external/npyscreen/fmFormMuttActive.py',
 'leo/external/npyscreen/fmFormWithMenus.py': '../external/npyscreen/fmFormWithMenus.py',
 'leo/external/npyscreen/fmPopup.py': '../external/npyscreen/fmPopup.py',
 'leo/external/npyscreen/fm_form_edit_loop.py': '../external/npyscreen/fm_form_edit_loop.py',
 'leo/external/npyscreen/globals.py': '../external/npyscreen/globals.py',
 'leo/external/npyscreen/muMenu.py': '../external/npyscreen/muMenu.py',
 'leo/external/npyscreen/muNewMenu.py': '../external/npyscreen/muNewMenu.py',
 'leo/external/npyscreen/npysGlobalOptions.py': '../external/npyscreen/npysGlobalOptions.py',
 'leo/external/npyscreen/npysNPSFilteredData.py': '../external/npyscreen/npysNPSFilteredData.py',
 'leo/external/npyscreen/npysThemeManagers.py': '../external/npyscreen/npysThemeManagers.py',
 'leo/external/npyscreen/npysThemes.py': '../external/npyscreen/npysThemes.py',
 'leo/external/npyscreen/npysTree.py': '../external/npyscreen/npysTree.py',
 'leo/external/npyscreen/npyspmfuncs.py': '../external/npyscreen/npyspmfuncs.py',
 'leo/external/npyscreen/npyssafewrapper.py': '../external/npyscreen/npyssafewrapper.py',
 'leo/external/npyscreen/proto_fm_screen_area.py': '../external/npyscreen/proto_fm_screen_area.py',
 'leo/external/npyscreen/stdfmemail.py': '../external/npyscreen/stdfmemail.py',
 'leo/external/npyscreen/utilNotify.py': '../external/npyscreen/utilNotify.py',
 'leo/external/npyscreen/util_viewhelp.py': '../external/npyscreen/util_viewhelp.py',
 'leo/external/npyscreen/wgFormControlCheckbox.py': '../external/npyscreen/wgFormControlCheckbox.py',
 'leo/external/npyscreen/wgNMenuDisplay.py': '../external/npyscreen/wgNMenuDisplay.py',
 'leo/external/npyscreen/wgannotatetextbox.py': '../external/npyscreen/wgannotatetextbox.py',
 'leo/external/npyscreen/wgautocomplete.py': '../external/npyscreen/wgautocomplete.py',
 'leo/external/npyscreen/wgboxwidget.py': '../external/npyscreen/wgboxwidget.py',
 'leo/external/npyscreen/wgbutton.py': '../external/npyscreen/wgbutton.py',
 'leo/external/npyscreen/wgcheckbox.py': '../external/npyscreen/wgcheckbox.py',
 'leo/external/npyscreen/wgcombobox.py': '../external/npyscreen/wgcombobox.py',
 'leo/external/npyscreen/wgdatecombo.py': '../external/npyscreen/wgdatecombo.py',
 'leo/external/npyscreen/wgeditmultiline.py': '../external/npyscreen/wgeditmultiline.py',
 'leo/external/npyscreen/wgfilenamecombo.py': '../external/npyscreen/wgfilenamecombo.py',
 'leo/external/npyscreen/wggrid.py': '../external/npyscreen/wggrid.py',
 'leo/external/npyscreen/wggridcoltitles.py': '../external/npyscreen/wggridcoltitles.py',
 'leo/external/npyscreen/wgmonthbox.py': '../external/npyscreen/wgmonthbox.py',
 'leo/external/npyscreen/wgmultiline.py': '../external/npyscreen/wgmultiline.py',
 'leo/external/npyscreen/wgmultilineeditable.py': '../external/npyscreen/wgmultilineeditable.py',
 'leo/external/npyscreen/wgmultilinetree.py': '../external/npyscreen/wgmultilinetree.py',
 'leo/external/npyscreen/wgmultilinetreeselectable.py': '../external/npyscreen/wgmultilinetreeselectable.py',
 'leo/external/npyscreen/wgmultiselect.py': '../external/npyscreen/wgmultiselect.py',
 'leo/external/npyscreen/wgmultiselecttree.py': '../external/npyscreen/wgmultiselecttree.py',
 'leo/external/npyscreen/wgpassword.py': '../external/npyscreen/wgpassword.py',
 'leo/external/npyscreen/wgselectone.py': '../external/npyscreen/wgselectone.py',
 'leo/external/npyscreen/wgslider.py': '../external/npyscreen/wgslider.py',
 'leo/external/npyscreen/wgtextbox.py': '../external/npyscreen/wgtextbox.py',
 'leo/external/npyscreen/wgtextbox_controlchrs.py': '../external/npyscreen/wgtextbox_controlchrs.py',
 'leo/external/npyscreen/wgtextboxunicode.py': '../external/npyscreen/wgtextboxunicode.py',
 'leo/external/npyscreen/wgtexttokens.py': '../external/npyscreen/wgtexttokens.py',
 'leo/external/npyscreen/wgtitlefield.py': '../external/npyscreen/wgtitlefield.py',
 'leo/external/npyscreen/wgwidget.py': '../external/npyscreen/wgwidget.py',
 'leo/external/npyscreen/wgwidget_proto.py': '../external/npyscreen/wgwidget_proto.py',
 'leo/external/obsolete/ipy_leo.py': '../external/obsolete/ipy_leo.py',
 'leo/external/py2cs.py': '../external/py2cs.py',
 'leo/external/sax2db.py': '../external/sax2db.py',
 'leo/plugins/FileActions.py': 'FileActions.py',
 'leo/plugins/active_path.py': 'active_path.py',
 'leo/plugins/add_directives.py': 'add_directives.py',
 'leo/plugins/at_folder.py': 'at_folder.py',
 'leo/plugins/at_produce.py': 'at_produce.py',
 'leo/plugins/at_view.py': 'at_view.py',
 'leo/plugins/attrib_edit.py': 'attrib_edit.py',
 'leo/plugins/auto_colorize2_0.py': 'auto_colorize2_0.py',
 'leo/plugins/backlink.py': 'backlink.py',
 'leo/plugins/baseNativeTree.py': '../plugins/baseNativeTree.py',
 'leo/plugins/bibtex.py': 'bibtex.py',
 'leo/plugins/bigdash.py': 'bigdash.py',
 'leo/plugins/bookmarks.py': 'bookmarks.py',
 'leo/plugins/bzr_qcommands.py': 'bzr_qcommands.py',
 'leo/plugins/chapter_hoist.py': 'chapter_hoist.py',
 'leo/plugins/codewisecompleter.py': 'codewisecompleter.py',
 'leo/plugins/colorize_headlines.py': 'colorize_headlines.py',
 'leo/plugins/contextmenu.py': 'contextmenu.py',
 'leo/plugins/ctagscompleter.py': 'ctagscompleter.py',
 'leo/plugins/cursesGui.py': 'cursesGui.py',
 'leo/plugins/cursesGui2.py': 'cursesGui2.py',
 'leo/plugins/datenodes.py': 'datenodes.py',
 'leo/plugins/debugger_pudb.py': 'debugger_pudb.py',
 'leo/plugins/demo.py': 'demo.py',
 'leo/plugins/dragdropgoodies.py': 'dragdropgoodies.py',
 'leo/plugins/dtest.py': 'dtest.py',
 'leo/plugins/dump_globals.py': 'dump_globals.py',
 'leo/plugins/empty_leo_file.py': 'empty_leo_file.py',
 'leo/plugins/enable_gc.py': 'enable_gc.py',
 'leo/plugins/examples/chinese_menu.py': 'examples/chinese_menu.py',
 'leo/plugins/examples/french_fm.py': 'examples/french_fm.py',
 'leo/plugins/examples/override_classes.py': 'examples/override_classes.py',
 'leo/plugins/examples/override_commands.py': 'examples/override_commands.py',
 'leo/plugins/examples/print_cp.py': 'examples/print_cp.py',
 'leo/plugins/examples/redefine_put.py': 'examples/redefine_put.py',
 'leo/plugins/expfolder.py': 'expfolder.py',
 'leo/plugins/free_layout.py': '../plugins/free_layout.py',
 'leo/plugins/ftp.py': 'ftp.py',
 'leo/plugins/geotag.py': 'geotag.py',
 'leo/plugins/gitarchive.py': 'gitarchive.py',
 'leo/plugins/graphcanvas.py': 'graphcanvas.py',
 'leo/plugins/import_cisco_config.py': 'import_cisco_config.py',
 'leo/plugins/importers/__init__.py': 'importers/__init__.py',
 'leo/plugins/importers/c.py': 'importers/c.py',
 'leo/plugins/importers/coffeescript.py': 'importers/coffeescript.py',
 'leo/plugins/importers/csharp.py': 'importers/csharp.py',
 'leo/plugins/importers/ctext.py': 'importers/ctext.py',
 'leo/plugins/importers/dart.py': 'importers/dart.py',
 'leo/plugins/importers/elisp.py': 'importers/elisp.py',
 'leo/plugins/importers/html.py': 'importers/html.py',
 'leo/plugins/importers/ini.py': 'importers/ini.py',
 'leo/plugins/importers/ipynb.py': 'importers/ipynb.py',
 'leo/plugins/importers/java.py': 'importers/java.py',
 'leo/plugins/importers/javascript.py': 'importers/javascript.py',
 'leo/plugins/importers/json.py': 'importers/json.py',
 'leo/plugins/importers/leo_rst.py': 'importers/leo_rst.py',
 'leo/plugins/importers/linescanner.py': 'importers/linescanner.py',
 'leo/plugins/importers/lua.py': 'importers/lua.py',
 'leo/plugins/importers/markdown.py': 'importers/markdown.py',
 'leo/plugins/importers/org.py': 'importers/org.py',
 'leo/plugins/importers/otl.py': 'importers/otl.py',
 'leo/plugins/importers/pascal.py': 'importers/pascal.py',
 'leo/plugins/importers/perl.py': 'importers/perl.py',
 'leo/plugins/importers/php.py': 'importers/php.py',
 'leo/plugins/importers/python.py': 'importers/python.py',
 'leo/plugins/importers/tcl.py': 'importers/tcl.py',
 'leo/plugins/importers/typescript.py': 'importers/typescript.py',
 'leo/plugins/importers/xml.py': 'importers/xml.py',
 'leo/plugins/initinclass.py': 'initinclass.py',
 'leo/plugins/interact.py': 'interact.py',
 'leo/plugins/jinjarender.py': 'jinjarender.py',
 'leo/plugins/leoOPML.py': 'leoOPML.py',
 'leo/plugins/leoPluginNotes.txt': 'leoPluginNotes.txt',
 'leo/plugins/leo_interface.py': 'leo_interface.py',
 'leo/plugins/leo_pdf.py': 'leo_pdf.py',
 'leo/plugins/leo_to_html.py': 'leo_to_html.py',
 'leo/plugins/leo_to_rtf.py': 'leo_to_rtf.py',
 'leo/plugins/leocursor.py': 'leocursor.py',
 'leo/plugins/leofeeds.py': 'leofeeds.py',
 'leo/plugins/leomail.py': 'leomail.py',
 'leo/plugins/leomylyn.py': 'leomylyn.py',
 'leo/plugins/leoremote.py': 'leoremote.py',
 'leo/plugins/leoscreen.py': 'leoscreen.py',
 'leo/plugins/lineNumbers.py': 'lineNumbers.py',
 'leo/plugins/livecode.py': 'livecode.py',
 'leo/plugins/macros.py': 'macros.py',
 'leo/plugins/markup_inline.py': 'markup_inline.py',
 'leo/plugins/maximizeNewWindows.py': 'maximizeNewWindows.py',
 'leo/plugins/mime.py': 'mime.py',
 'leo/plugins/mnplugins.py': 'mnplugins.py',
 'leo/plugins/mod_autosave.py': 'mod_autosave.py',
 'leo/plugins/mod_framesize.py': 'mod_framesize.py',
 'leo/plugins/mod_http.py': 'mod_http.py',
 'leo/plugins/mod_leo2ascd.py': 'mod_leo2ascd.py',
 'leo/plugins/mod_leo2ascd.txt': 'mod_leo2ascd.txt',
 'leo/plugins/mod_read_dir_outline.py': 'mod_read_dir_outline.py',
 'leo/plugins/mod_scripting.py': 'mod_scripting.py',
 'leo/plugins/mod_speedups.py': 'mod_speedups.py',
 'leo/plugins/mod_timestamp.py': 'mod_timestamp.py',
 'leo/plugins/multifile.py': 'multifile.py',
 'leo/plugins/nav_qt.py': 'nav_qt.py',
 'leo/plugins/nested_splitter.py': '../plugins/nested_splitter.py',
 'leo/plugins/niceNosent.py': 'niceNosent.py',
 'leo/plugins/nodeActions.py': 'nodeActions.py',
 'leo/plugins/nodediff.py': 'nodediff.py',
 'leo/plugins/nodetags.py': 'nodetags.py',
 'leo/plugins/nodewatch.py': 'nodewatch.py',
 'leo/plugins/notebook.py': 'notebook.py',
 'leo/plugins/obsolete/ironPythonGui.py': './obsolete/ironPythonGui.py',
 'leo/plugins/obsolete/swing_gui.py': './obsolete/swing_gui.py',
 'leo/plugins/obsolete/tkGui.py': './obsolete/tkGui.py',
 'leo/plugins/obsolete/wxGui.py': './obsolete/wxGui.py',
 'leo/plugins/open_shell.py': 'open_shell.py',
 'leo/plugins/outline_export.py': 'outline_export.py',
 'leo/plugins/paste_as_headlines.py': 'paste_as_headlines.py',
 'leo/plugins/plugins_menu.py': 'plugins_menu.py',
 'leo/plugins/pretty_print.py': 'pretty_print.py',
 'leo/plugins/projectwizard.py': 'projectwizard.py',
 'leo/plugins/pyplot_backend.py': 'pyplot_backend.py',
 'leo/plugins/python_terminal.py': 'python_terminal.py',
 'leo/plugins/qtGui.py': '../plugins/qtGui.py',
 'leo/plugins/qtNotes.txt': 'qtNotes.txt',
 'leo/plugins/qt_commands.py': '../plugins/qt_commands.py',
 'leo/plugins/qt_events.py': '../plugins/qt_events.py',
 'leo/plugins/qt_frame.py': '../plugins/qt_frame.py',
 'leo/plugins/qt_gui.py': '../plugins/qt_gui.py',
 'leo/plugins/qt_idle_time.py': '../plugins/qt_idle_time.py',
 'leo/plugins/qt_quickheadlines.py': '../plugins/qt_quickheadlines.py',
 'leo/plugins/qt_text.py': '../plugins/qt_text.py',
 'leo/plugins/qt_tree.py': '../plugins/qt_tree.py',
 'leo/plugins/quickMove.py': 'quickMove.py',
 'leo/plugins/quicksearch.py': 'quicksearch.py',
 'leo/plugins/quit_leo.py': 'quit_leo.py',
 'leo/plugins/read_only_nodes.py': 'read_only_nodes.py',
 'leo/plugins/redirect_to_log.py': 'redirect_to_log.py',
 'leo/plugins/richtext.py': 'richtext.py',
 'leo/plugins/rss.py': 'rss.py',
 'leo/plugins/rst3.py': 'rst3.py',
 'leo/plugins/run_nodes.py': 'run_nodes.py',
 'leo/plugins/screen_capture.py': 'screen_capture.py',
 'leo/plugins/screencast.py': 'screencast.py',
 'leo/plugins/screenshots.py': 'screenshots.py',
 'leo/plugins/script_io_to_body.py': 'script_io_to_body.py',
 'leo/plugins/scripts_menu.py': 'scripts_menu.py',
 'leo/plugins/setHomeDirectory.py': 'setHomeDirectory.py',
 'leo/plugins/settings_finder.py': 'settings_finder.py',
 'leo/plugins/sftp.py': 'sftp.py',
 'leo/plugins/slideshow.py': 'slideshow.py',
 'leo/plugins/spydershell.py': 'spydershell.py',
 'leo/plugins/startfile.py': 'startfile.py',
 'leo/plugins/stickynotes.py': 'stickynotes.py',
 'leo/plugins/stickynotes_plus.py': 'stickynotes_plus.py',
 'leo/plugins/systray.py': 'systray.py',
 'leo/plugins/tables.py': 'tables.py',
 'leo/plugins/template_gui.py': 'template_gui.py',
 'leo/plugins/test/ekr_test.py': 'test/ekr_test.py',
 'leo/plugins/test/failed_import.py': 'test/failed_import.py',
 'leo/plugins/test/failed_to_load_plugin.py': 'test/failed_to_load_plugin.py',
 'leo/plugins/test/syntax_error_plugin.py': 'test/syntax_error_plugin.py',
 'leo/plugins/testRegisterCommand.py': 'testRegisterCommand.py',
 'leo/plugins/textnode.py': 'textnode.py',
 'leo/plugins/threadutil.py': 'threadutil.py',
 'leo/plugins/timestamp.py': 'timestamp.py',
 'leo/plugins/todo.py': 'todo.py',
 'leo/plugins/tomboy_import.py': 'tomboy_import.py',
 'leo/plugins/trace_gc_plugin.py': 'trace_gc_plugin.py',
 'leo/plugins/trace_keys.py': 'trace_keys.py',
 'leo/plugins/trace_tags.py': 'trace_tags.py',
 'leo/plugins/valuespace.py': 'valuespace.py',
 'leo/plugins/viewrendered.py': 'viewrendered.py',
 'leo/plugins/viewrendered2.py': 'viewrendered2.py',
 'leo/plugins/vim.py': 'vim.py',
 'leo/plugins/vnodes-history.py': 'vnodes-history.py',
 'leo/plugins/wikiview.py': 'wikiview.py',
 'leo/plugins/word_count.py': 'word_count.py',
 'leo/plugins/word_export.py': 'word_export.py',
 'leo/plugins/writers/__init__.py': 'writers/__init__.py',
 'leo/plugins/writers/basewriter.py': 'writers/basewriter.py',
 'leo/plugins/writers/ctext.py': 'writers/ctext.py',
 'leo/plugins/writers/dart.py': 'writers/dart.py',
 'leo/plugins/writers/ipynb.py': 'writers/ipynb.py',
 'leo/plugins/writers/json.py': 'writers/json.py',
 'leo/plugins/writers/leo_rst.py': 'writers/leo_rst.py',
 'leo/plugins/writers/markdown.py': 'writers/markdown.py',
 'leo/plugins/writers/org.py': 'writers/org.py',
 'leo/plugins/writers/otl.py': 'writers/otl.py',
 'leo/plugins/writers/test.py': 'writers/test.py',
 'leo/plugins/xemacs.py': 'xemacs.py',
 'leo/plugins/xml_edit.py': 'xml_edit.py',
 'leo/plugins/xsltWithNodes.py': 'xsltWithNodes.py',
 'leo/plugins/zenity_file_dialogs.py': 'zenity_file_dialogs.py',
 'leo/scripts/build-leo.bat': 'build-leo.bat',
 'leo/scripts/elevate.py': 'elevate.py',
 'leo/scripts/gen_blender_docs.py': 'gen_blender_docs.py',
 'leo/scripts/leoScripts.txt': 'leoScripts.txt',
 'leo/scripts/register-leo.leox': 'register-leo.leox',
 'leo/scripts/unregister-leo.leox': 'unregister-leo.leox',
 'leo/test/activeUnitTests.txt': 'activeUnitTests.txt',
 'leo/test/inactiveTests.txt': 'inactiveTests.txt',
 'leo/test/unitTestStartup.txt': 'unitTestStartup.txt',
 'leo/test/unittest/at-file-line-number-test.c': 'unittest/at-file-line-number-test.c',
 'leo/test/unittest/at-file-line-number-test.py': 'unittest/at-file-line-number-test.py',
 'leo/test/unittest/at-path-test1.py': '../test/unittest/at-path-test1.py',
 'leo/test/unittest/at-path-test2.py': 'at-path-test2.py',
 'leo/test/unittest/at-path-test3.py': 'at-path-test3.py',
 'leo/test/unittest/at-thin-html-test.html': 'unittest/at-thin-html-test.html--&gt;',
 'leo/test/unittest/at-thin-line-number-test.py': 'unittest/at-thin-line-number-test.py',
 'leo/test/unittest/at-thin-test.py': 'unittest/at-thin-test.py',
 'leo/test/unittest/batchTest.py': 'unittest/batchTest.py',
 'leo/test/unittest/errorTest.py': 'unittest/errorTest.py',
 'leo/test/unittest/tex-error.tex': 'unittest/tex-error.tex'}</t>
<t tx="vitalije.20170720214432.6">_files_cache = {}
def get_file(n):
    fname = derived_files[n] if type(n) is int else n
    s = _files_cache.get(fname)
    if s:
        return s
    s = g.readFileIntoUnicodeString(fname)
    s = s.replace('\r','')
    _files_cache[fname] = s
    return s</t>
<t tx="vitalije.20170720214432.7">def get_lines(n):
    return g.splitLines(get_file(n))</t>
<t tx="vitalije.20170720214432.8">def headline_for_ideal_import(j):
    flines = enumerate(get_lines(j))
    ver, kind, delim_st, delim_en = read_header(flines)
    ptrns = get_patterns(delim_st)
    pat = ptrns.node_start
    for i, line in flines:
        m = at_node_start(i, line, pat)
        if not m: continue
        break
    else:
        return
    hfi = m[-1].strip()
    if hfi.endswith('--&gt;'):
        hfi = hfi[:-3].strip()
    return hfi</t>
<t tx="vitalije.20170720214432.9">def ideal_path_for_import(j):
    fn = derived_files[j]
    if fn.find('leo/doc/sphinx-docs') &gt; -1:
        return '%s/doc/sphinx-docs'%g.app.leoDir
    elif fn.find('leo/doc/') &gt; -1:
        return '%s/doc'%g.app.leoDir
    elif fn.find('leo/scripts/') &gt; -1:
        return '%s/scripts'%g.app.leoDir
    elif fn.find('leo/plugins/') &gt; -1:
        return '%s/plugins'%g.app.leoDir
    elif j == 392:
        return '%s/dist/junk/junk'%g.app.leoDir
    elif j in (400, 401):
        return '%s/test/unittest'%g.app.leoDir
    elif fn.find('leo/test/') &gt; -1:
        return '%s/test'%g.app.leoDir
    else:
        return '%s/core'%g.app.leoDir</t>
<t tx="vitalije.20170720214543.2">At first this file contained only scripts in `exp-3 dev` node.
&lt;&lt;about exp-3 dev&gt;&gt; original about this file

About exp-4 dev 

.. now 2017-07-21 13:39:02.725184

Work on read derived files continues on. Right now when executing script
in `exp-4 dev` node, Leo will compare reading of almost all derived files
that could be found in Leo installation directory. Except for some 
ancient derived file formats and some files that have @+leo inside, but
are not real derived files (false_positives), all other derived files
can be successfully read by new reading code.

The only file that new reading code still can't read is activeUnitTests.txt
located in leo/test/ directory. This file contains some at-raw, and 
at-asis directives that are still not recognizable by new reading code.

</t>
<t tx="vitalije.20170720214636.1"></t>
<t tx="vitalije.20170721074235.1">This file contains scripts that test how fast can be calculated
line number in external file for any given line in at-anyfile
subtree.

To run test code in `exp-3 dev @key=Alt-4` should be executed.

It first imports leo/core/leoApp.py derived file under the
EXTERNALS node as the first child.

Then it patches leo.core.VNode class adding .lines get-property
which aims to reduce the number of using g.splitLines.

Then it profiles function f_line_numerate which visits the 
subtree of at-file node and to each vnode in subtree it attaches
f_lines tuple which contains ordering numbers of lines in that
node. This property can be displayed in gutter for example.

Profiling on my machine shows that it is able to renumerate
whole subtree 100 times in less than 1.8 secodns which gives
on average 18ms per renumeration.

Note: this is just an experiment and code is not thoroughly
tested neither it is proved to be correct for all possible
Leo directives. However, it most probably can be fixed if
any error in line numbering is noticed.</t>
<t tx="vitalije.20170721074430.1">import itertools
import re
import leo.core.leoNodes as leoNodes
import timeit
import pprint
@others
c.frame.log.selectTab('Log')
c.frame.log.clearLog()
compare_reading_all_files()

g.es(len(tuple(valid_files())) - 1, 'files successfully read')

clear_gnxDict()
c.redraw()</t>
<t tx="vitalije.20170721075007.1">def run_experiment(func, n, keep_node=False):
    p = c.find_h('EXTERNALS')[0]
    ok = False
    try:
        do_import_file(n)
        c.redraw()
        ok = func(n, p.lastChild())
        if ok:
            g.es('ok')
        else:
            g.es('experiment', func.__name__, 'failed')
    except Exception as e:
        g.es_exception(e)
        g.traceback.print_exc()
    finally:
        if not keep_node:
            p.lastChild().doDelete()
            clear_gnxDict()
    return ok</t>
<t tx="vitalije.20170721075016.1"></t>
<t tx="vitalije.20170721075355.1">def valid_files():
    for j,n in enumerate(derived_files):
        if j not in false_positives:
            yield j, n</t>
<t tx="vitalije.20170721083818.1">leo_header_pat = re.compile('^(.+?)@[+]leo-ver=(\\d+)-(thin|file)(.*?)\n$')
def read_header(flines):
    for i, line in flines:
        m = leo_header_pat.match(line)
        if m:
            return (m.group(2), # version
                    m.group(3), # kind
                    m.group(1), # delim_start
                    m.group(4), # delim_end
                )</t>
<t tx="vitalije.20170721090011.1">def at_sect_ref(i, line, pat):
    m = pat.match(line)
    if m:
        return (i, # line no
                m.group(1), #indent
                m.group(3), #section ref
                m.group(2) == '+', #is_start
                m.group(4)) #after sect ref
    else:
        return False</t>
<t tx="vitalije.20170721090017.1">def sect_refs(data):
    flines, ptrns, verbatims = data
    pat = ptrns.section

    starts = []

    for i, line in flines:

        if i in verbatims: continue

        m = at_sect_ref(i, line, pat)
        if not m: continue

        j, indent, sref, is_start, after = m

        if is_start:
            starts.append(m)
        else:
            m_st = starts.pop()
            j, indent, sref, is_start, after = m_st
            yield (j, i, indent, sref, after)</t>
<t tx="vitalije.20170721090105.1">patterns = {
    '#': g.bunch(
            node_start = re.compile('^(\\s*)#@[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*)$', re.DOTALL),
            section = re.compile('^(\\s*)#@([+]|-)&lt;{2}(.+?)&gt;{2}(.*)$',
                            re.DOTALL),
            others = re.compile('^(\\s*)#@([+]|-)others\\s*$', re.DOTALL),
            all = re.compile('^(\\s*)#@([+]|-)all\\s*$', re.DOTALL),
        ),
    '.. ': g.bunch(
            node_start = re.compile('^(\\s*)[.][.] @[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*)$', re.DOTALL),
            section = re.compile('^(\\s*)[.][.] @([+]|-)&lt;{2}(.+?)&gt;{2}(.*)$',
                            re.DOTALL),
            others = re.compile('^(\\s*)[.][.] @([+]|-)others\\s*$', re.DOTALL),
            all = re.compile('^(\\s*)[.][.] @([+]|-)all\\s*$', re.DOTALL),
        ),
    '&lt;!--': g.bunch(
            node_start = re.compile('^(\\s*)&lt;!--@[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*?)--&gt;$', re.DOTALL),
            section = re.compile('^(\\s*)&lt;!--@([+]|-)&lt;{2}(.+?)&gt;{2}--&gt;(.*?)$',
                                    re.DOTALL),
            others = re.compile('^(\\s*)&lt;!--@([+]|-)others--&gt;\\s*$', re.DOTALL),
            all = re.compile('^(\\s*)&lt;!--@([+]|-)all--&gt;\\s*$', re.DOTALL),
        ),
    '/*': g.bunch(
            node_start = re.compile('^(\\s*)/[*]@[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*?)[*]/$', re.DOTALL),
            section = re.compile('^(\\s*)/[*]@([+]|-)&lt;{2}(.+?)&gt;{2}[*]/(.*?)$',
                                     re.DOTALL),
            others = re.compile('^(\\s*)/[*]@([+]|-)others[*]/\\s*$', re.DOTALL),
            all = re.compile('^(\\s*)/[*]@([+]|-)all[*]/\\s*$', re.DOTALL),
        ),
    '//': g.bunch(
            node_start = re.compile('^(\\s*)//@[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*)$', re.DOTALL),
            section = re.compile('^(\\s*)//@([+]|-)&lt;{2}(.+?)&gt;{2}(.*)$',
                                    re.DOTALL),
            others = re.compile('^(\\s*)//@([+]|-)others\\s*$', re.DOTALL),
            all = re.compile('^(\\s*)//@([+]|-)all\\s*$', re.DOTALL),
        ),
    ';': g.bunch(
            node_start = re.compile('^(\\s*);@[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*)$', re.DOTALL),
            section = re.compile('^(\\s*);@([+]|-)&lt;{2}(.+?)&gt;{2}(.*)$',
                                    re.DOTALL),
            others = re.compile('^(\\s*);@([+]|-)others\\s*$', re.DOTALL),
            all = re.compile('^(\\s*);@([+]|-)all\\s*$', re.DOTALL),
        ),
    'REM ': g.bunch(
            node_start = re.compile('^(\\s*)REM @[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*)$', re.DOTALL),
            section = re.compile('^(\\s*)REM @([+]|-)&lt;{2}(.+?)&gt;{2}(.*)$',
                                    re.DOTALL),
            others = re.compile('^(\\s*)REM @([+]|-)others\\s*$', re.DOTALL),
            all = re.compile('^(\\s*)REM @([+]|-)all\\s*$', re.DOTALL),
        ),
    '%': g.bunch(
            node_start = re.compile('^(\\s*)%@[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*)$', re.DOTALL),
            section = re.compile('^(\\s*)%@([+]|-)&lt;{2}(.+?)&gt;{2}(.*)$',
                                    re.DOTALL),
            others = re.compile('^(\\s*)%@([+]|-)others\\s*$', re.DOTALL),
            all = re.compile('^(\\s*)%@([+]|-)all\\s*$', re.DOTALL),
        ),
}</t>
<t tx="vitalije.20170721091325.1">def match_at_others(i, line, pat):
    m = pat.match(line)
    if m:
        return (i, m.group(1), m.group(2) == '+')
    else:
        return False</t>
<t tx="vitalije.20170721095723.1">def at_all_refs(data):
    flines, ptrns, verbatims = data
    pat = ptrns.all

    starts = []

    for i, line in flines:

        if i in verbatims: continue

        m = match_at_all(i, line, pat)

        if m and m[2]:
            starts.append(m)
        elif m:
            j, indent, junk = starts.pop()
            yield j, i, indent
</t>
<t tx="vitalije.20170721095723.3">def match_at_all(i, line, pat):
    m = pat.match(line)
    if m:
        return (i, m.group(1), m.group(2) == '+')
    else:
        return False</t>
<t tx="vitalije.20170721100518.1">def read_verbatims(flines, delim_st):
    st = delim_st + '@verbatim'
    in_verb = False
    for i, line in flines:
        if in_verb:
            yield i
            in_verb = False
        else:
            in_verb = line.startswith(st)</t>
<t tx="vitalije.20170721100524.1">def find_all(n, at_all_data):
    '''Returns at-all block starting on line n, or
       first following block. If such block can't
       be found, returns None.'''

    # Note: at-all blocks can't be nested nor they can overlap
    #       and at_all_data is in ascending order
    for i, j, ws in at_all_data:
        if i &lt; n: continue
        return i, j, ws

</t>
<t tx="vitalije.20170721131019.1">end_delimiters = {
    '&lt;!--': '-''-&gt;',
    '/*': '*''/'
}
def strip_end_delimiter(line, delim_st):
    delim_en = end_delimiters.get(delim_st)
    if delim_en:
        i = line.rfind(delim_en)
        if i &gt; -1:
            return line[:i] + line[i + len(delim_en):]
    return line</t>
<t tx="vitalije.20170721173437.1">def read_at_last_lines(analytics):
    a = analytics; flines = a.flines
    leo_end = a.delim_st + '@-leo'
    j, line = flines[-1]
    while j &gt; 0:
        if line.startswith(leo_end):
            # last lines comes after at-leo sentinel line
            break
        # going backword from the end of file
        j, line = flines[j - 1]

    # in j is index of at-leo sentinel line
    for i, line in flines[j+1:]:
        yield line</t>
<t tx="vitalije.20170721174314.1">def indent(n, s):
    return ' ' * n + s</t>
<t tx="vitalije.20170721180227.1">def end_of_node_in_all(st, end_all, analytics):
    a = analytics
    # inside at-all block: 
    #      node ends on first next node start
    #      or at the end of at-all block
    is_gt = lambda x: x &gt; st
    after_nodes = filter(is_gt, a.nstart.keys())
    return min(after_nodes, default=end_all)</t>
<t tx="vitalije.20170721180649.1">def end_of_node_in_others(st, lev, analytics):
    a = analytics
    # in others block node ends at the end of others block
    # or on the beginning of node at the same level or upper  
    j = len(a.flines)
    for gnx, nd in a.nodes.items():
        for (i, lev2, h2, wsp) in nd:
            if lev2 &lt;= lev and i &gt; st:
                j = min(j, i)
    return j</t>
<t tx="vitalije.20170721184930.1">def get_patterns(delim_st):
    ptrns = patterns.get(delim_st)
    if not ptrns:
        g.error('no valid patterns for delimiter: %r'%delim_st)
    return ptrns</t>
<t tx="vitalije.20170721190334.1"></t>
<t tx="vitalije.20170721192544.1">if i in verbatims:
    # verbatim line: yield it as it is
    yield flines[i][1]
    i += 1</t>
<t tx="vitalije.20170721192602.1">elif i + 1 in verbatims:
    # skip verbatim sentinel
    i += 1</t>
<t tx="vitalije.20170721192639.1">elif all_ij and i == all_ij[0]:
    # we are on the beginning of at-all block
    i = all_ij[1] + 1 # after at-all block
    yield all_ij[2][ind:] + '@all\n'
    # find next at-all block
    all_ij = find_all(i, a.atall)</t>
<t tx="vitalije.20170721192649.1">elif i in a.othrs:
    # we are on the beginning of at-others block
    en, wsp = a.othrs[i]
    i = en + 1 # after at-others block
    yield indent(wsp - ind, '@others\n')</t>
<t tx="vitalije.20170721192800.1">elif i in a.sects:
    # we are on the beginning of section block
    en, wsp, sref, after = a.sects[i]
    i = en + 1 # after section block
    # if there was delim_end, the newline was striped
    nl = '' if after.endswith('\n') else '\n'
    yield indent(wsp - ind, g.angleBrackets(sref) + after + nl)</t>
<t tx="vitalije.20170721192809.1">elif i in a.nstart:
    # we are at the beginning of node
    gnx2 = a.nstart[i]
    en = end_of_node(gnx2, analytics)
    i = en</t>
<t tx="vitalije.20170721192819.1">elif i in a.oend:
    # nothing to do if we are at the end of at-others
    break</t>
<t tx="vitalije.20170721192855.1">else:
    line = flines[i][1]
    if len(line) &lt; ind:
        # perhaps line was empty and we are at some indent
        # using line[ind:] would strip newline
        yield line
    else:
        yield line[ind:]
    i += 1</t>
<t tx="vitalije.20170721193719.1"></t>
<t tx="vitalije.20170721194006.1">head = read_header(flines)
if not head:
    g.warning('no valid header. is this really derived file?')
ver, kind, delim_st, delim_en = head</t>
<t tx="vitalije.20170721194026.1">verbatims = tuple(read_verbatims(flines, delim_st))</t>
<t tx="vitalije.20170721194127.1">data = flines, get_patterns(delim_st), verbatims</t>
<t tx="vitalije.20170721194142.1">at_all_data = tuple(at_all_refs(data))</t>
<t tx="vitalije.20170721194157.1">@ in at-all files there are multiple at+node sentinels
  with the same gnx for cloned nodes. So node_data must
  contain tuple of node data tuples for any gnx.
@c

node_data = {}
for i, ind, gnx, lev, h in node_start_lines(data):
    t = node_data.get(gnx, tuple()) # previous or new empty tuple
    nd = (i, lev, h, len(ind)) # tuple of node data (for one instance of node)
    node_data[gnx] = t + (nd,) #  add this data to tuple for this gnx

# node_starts: keys are indexes of starting line, values are gnxes
node_starts = dict((x[0], x[2]) for x in node_start_lines(data))</t>
<t tx="vitalije.20170721194206.1"># sect_refs yields tuples of the following form:
#
#      start, end, ident_str, reference name and after reference text
#       0   |  1   |   2     |          3     |           4          |
#
sdata_fun = lambda x:(x[1], len(x[2]), x[3], x[4])

# key is start, value is (end, len(ident), ref, afterref)
sect_data = dict((x[0], sdata_fun(x)) for x in sect_refs(data))</t>
<t tx="vitalije.20170721194213.1"># keys are index of start line, values are tuples of (end, len(indent))
at_oth_data = dict((st, (en, len(ind))) for st,en,ind in at_others_refs(data))

# ending line indexes for at-others sentinels
oth_ends = set(x[0] for x in at_oth_data.values())</t>
<t tx="vitalije.20170721201600.1">def compare_reading_file(n, p):
    analytics = analyze_lines(get_lines(n))
    for i, p1 in enumerate(p.self_and_subtree()):
        gnx = p1.gnx
        v = c.fileCommands.gnxDict[gnx]
        if i == 0:
            s = ''.join(body_lines_of_top_node(gnx, analytics))
        else:
            s = ''.join(body_lines_of_node(gnx, analytics))
        if v.b != s:
            g.es('\n',v.h)
            g.es(s)
            p1 = c.find_h(v.h)[0]
            c.redraw(p1)
            return False
        # if i % 35 == 34:
        #     g.es('.')
        # else:
        #     g.es('.', newline=False)
    return True</t>
<t tx="vitalije.20170721201605.1">def compare_reading_all_files():
    for i, fn in valid_files():
        if i == 395: continue
        # for faster testing only few files are tested
        # comment following line to test all files
        if i not in (32, 160, 180, 401):continue
        if not run_experiment(compare_reading_file, i, False):
            g.es('file number:', i)
            break</t>
</tnodes>
</leo_file>
