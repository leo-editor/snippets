<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="vitalije.20170720214543.2"><vh>About this experiment</vh>
<v t="vitalije.20170721074235.1"><vh>&lt;&lt;about exp-3 dev&gt;&gt;</vh></v>
<v t="vitalije.20170722193355.1"><vh>&lt;&lt;about exp-4 dev&gt;&gt;</vh></v>
<v t="vitalije.20170724100819.1"><vh>&lt;&lt;about exp-5 dev&gt;&gt;</vh></v>
<v t="vitalije.20170724101716.1"><vh>&lt;&lt;about exp-6 dev&gt;&gt;</vh></v>
<v t="vitalije.20170724230235.1"><vh>&lt;&lt;about exp-7 dev&gt;&gt;</vh></v>
</v>
<v t="vitalije.20170723192208.1"><vh>@settings</vh>
<v t="vitalije.20170723192228.1"><vh>pyflakes</vh>
<v t="vitalije.20170723192228.2"><vh>@bool run-pyflakes-on-write = True</vh></v>
<v t="vitalije.20170723192228.3"><vh>@bool run_pyflakes_on_unchanged_files = True</vh></v>
</v>
</v>
<v t="vitalije.20170720180020.1"><vh>exp-3 dev @key=Alt-4</vh>
<v t="vitalije.20170720214432.1"><vh>importing derived files</vh>
<v t="vitalije.20170720214432.2"><vh>derived-files</vh>
<v t="vitalije.20170720214432.3"><vh>false positives</vh></v>
<v t="vitalije.20170720214432.4"><vh>show_derived_files_statistics</vh></v>
<v t="vitalije.20170720214432.5"><vh>paths_data</vh></v>
</v>
<v t="vitalije.20170721075355.1"><vh>valid_files</vh></v>
<v t="vitalije.20170720214432.6"><vh>get_file</vh></v>
<v t="vitalije.20170720214432.7"><vh>get_lines</vh></v>
<v t="vitalije.20170720214432.8"><vh>headline_for_ideal_import</vh></v>
<v t="vitalije.20170720214432.9"><vh>ideal_path_for_import</vh></v>
<v t="vitalije.20170723154242.1"><vh>perfect_headlines</vh></v>
<v t="vitalije.20170720214432.10"><vh>scan_for_ideal_import</vh></v>
<v t="vitalije.20170720214432.11"><vh>try_import_file</vh></v>
<v t="vitalije.20170723154327.1"><vh>do_import_file</vh></v>
<v t="vitalije.20170720214432.12"><vh>clear gnxDict</vh></v>
<v t="vitalije.20170720214432.13"><vh>can_import_every_derived_file</vh></v>
<v t="vitalije.20170720214432.14"><vh>test_1</vh></v>
<v t="vitalije.20170722215608.1"><vh>get_conf</vh></v>
</v>
<v t="ekr.20170719102447.28"><vh>Read</vh>
<v t="vitalije.20170721090105.1"><vh>patterns</vh></v>
<v t="vitalije.20170721184930.1"><vh>get_patterns</vh></v>
<v t="ekr.20170719102447.29"><vh>node_start_lines</vh>
<v t="ekr.20170719102447.30"><vh>at_node_start</vh></v>
</v>
<v t="vitalije.20170721090017.1"><vh>sect_refs</vh>
<v t="vitalije.20170721090011.1"><vh>at_sect_ref</vh></v>
</v>
<v t="ekr.20170719102447.32"><vh>at_others_refs</vh>
<v t="vitalije.20170721091325.1"><vh>match_at_others</vh></v>
</v>
<v t="vitalije.20170721095723.1"><vh>at_all_refs</vh>
<v t="vitalije.20170721095723.3"><vh>match_at_all</vh></v>
</v>
<v t="vitalije.20170721193719.1"><vh>body lines ...</vh>
<v t="ekr.20170719102447.37"><vh>body_lines_of_top_node</vh></v>
<v t="ekr.20170719102447.33"><vh>body_lines_of_node</vh>
<v t="vitalije.20170721210632.1"><vh>in verbatim</vh></v>
<v t="vitalije.20170721210647.1"><vh>or verbatim</vh></v>
<v t="vitalije.20170721210702.1"><vh>at doc</vh></v>
<v t="vitalije.20170721210713.1"><vh>at code</vh></v>
</v>
<v t="ekr.20170719102447.34"><vh>body_raw_lines_of_node</vh>
<v t="vitalije.20170721192544.1"><vh>if in verbatims</vh></v>
<v t="vitalije.20170721192602.1"><vh>elif at verbatim sentinel</vh></v>
<v t="vitalije.20170721202706.1"><vh>elif in raw mode</vh></v>
<v t="vitalije.20170721203441.1"><vh>elif at raw start</vh></v>
<v t="vitalije.20170721192639.1"><vh>elif at-all starts</vh></v>
<v t="vitalije.20170721204227.1"><vh>elif in-all block</vh></v>
<v t="vitalije.20170721192649.1"><vh>elif at-others starts</vh></v>
<v t="vitalije.20170721192800.1"><vh>elif section starts</vh></v>
<v t="vitalije.20170721192809.1"><vh>elif node starts</vh></v>
<v t="vitalije.20170721192819.1"><vh>elif at-others end</vh></v>
<v t="vitalije.20170721192855.1"><vh>else ordinary line</vh></v>
</v>
<v t="ekr.20170719102447.35"><vh>check_at_doc</vh></v>
<v t="ekr.20170719102447.36"><vh>check_at_code</vh></v>
<v t="vitalije.20170721131019.1"><vh>strip_end_delimiter</vh></v>
</v>
<v t="ekr.20170719102447.38"><vh>end_of_node</vh>
<v t="vitalije.20170721180227.1"><vh>end_of_node_in_all</vh></v>
<v t="vitalije.20170721180649.1"><vh>end_of_node_in_others</vh></v>
</v>
<v t="ekr.20170719102447.39"><vh>analyze_lines</vh>
<v t="vitalije.20170721194006.1"><vh>header of derived file</vh></v>
<v t="vitalije.20170721194026.1"><vh>verbatims</vh></v>
<v t="vitalije.20170721194127.1"><vh>data for further analysis</vh></v>
<v t="vitalije.20170721194142.1"><vh>at_all data</vh></v>
<v t="vitalije.20170721194157.1"><vh>nodes data</vh></v>
<v t="vitalije.20170721194206.1"><vh>sections data</vh></v>
<v t="vitalije.20170721194213.1"><vh>at_others data</vh></v>
</v>
<v t="vitalije.20170721100524.1"><vh>find_all</vh></v>
<v t="vitalije.20170721100518.1"><vh>read_verbatims</vh></v>
<v t="ekr.20170719102447.40"><vh>children_gnxes</vh></v>
<v t="ekr.20170719102447.41"><vh>gnx2headline</vh></v>
<v t="ekr.20170719102447.42"><vh>read_at_first_lines</vh></v>
<v t="vitalije.20170721173437.1"><vh>read_at_last_lines</vh></v>
<v t="vitalije.20170721083818.1"><vh>read_header</vh></v>
</v>
<v t="ekr.20170719102447.10"><vh>Write</vh>
<v t="ekr.20170719102447.11"><vh>starting_pos</vh></v>
<v t="ekr.20170719102447.12"><vh>add_ident</vh></v>
<v t="ekr.20170719102447.13"><vh>cut_left</vh></v>
<v t="ekr.20170719102447.14"><vh>cut_right</vh></v>
<v t="ekr.20170719102447.15"><vh>section_ref</vh></v>
<v t="ekr.20170719102447.16"><vh>before_double_gt</vh></v>
<v t="ekr.20170719102447.17"><vh>after_str</vh></v>
<v t="ekr.20170719102447.18"><vh>MissingSection</vh></v>
<v t="ekr.20170719102447.19"><vh>others_iterator</vh></v>
<v t="ekr.20170719102447.20"><vh>section_replacer</vh></v>
<v t="vitalije.20170722151650.1"><vh>joiner</vh></v>
<v t="vitalije.20170722173013.1"><vh>open_node</vh></v>
<v t="ekr.20170719102447.21"><vh>body_lines</vh>
<v t="vitalije.20170722211247.1"><vh>verbatim</vh></v>
<v t="vitalije.20170722201910.1"><vh>first lines &amp; leo header</vh></v>
<v t="vitalije.20170722202024.1"><vh>last lines</vh></v>
</v>
<v t="vitalije.20170722144500.1"><vh>needs_verbatim</vh></v>
<v t="ekr.20170719102447.22"><vh>others_replacer</vh></v>
<v t="vitalije.20170722203602.1"><vh>atall_replacer</vh></v>
<v t="vitalije.20170722174341.1"><vh>log_it debug iterator</vh></v>
<v t="ekr.20170719102447.23"><vh>all_lines</vh></v>
<v t="ekr.20170719102447.24"><vh>at_docer</vh>
<v t="vitalije.20170722133741.1"><vh>at, at-doc</vh></v>
<v t="vitalije.20170722133822.1"><vh>at-c at-code</vh></v>
</v>
<v t="ekr.20170719102447.25"><vh>at_adder</vh></v>
<v t="ekr.20170719102447.26"><vh>star_level</vh></v>
</v>
<v t="vitalije.20170720181053.1"><vh>patch VNode</vh>
<v t="vitalije.20170720181045.1"><vh>vnode_get_lines</vh></v>
<v t="vitalije.20170720190022.1"><vh>total_lines</vh></v>
<v t="vitalije.20170720190205.1"><vh>has_others</vh></v>
<v t="vitalije.20170720182924.1"><vh>one_line_directives</vh></v>
<v t="vitalije.20170720192016.1"><vh>vnode_how_many_from_this_line</vh></v>
<v t="vitalije.20170720194135.1"><vh>vnode_f_lines</vh></v>
</v>
</v>
<v t="vitalije.20170721074430.1"><vh>exp-4 dev @key=Alt-4</vh>
<v t="vitalije.20170721075016.1"><vh>cloned</vh>
<v t="vitalije.20170720214432.1"></v>
<v t="vitalije.20170721190334.1"><vh>Utils</vh>
<v t="vitalije.20170721174314.1"><vh>indent</vh></v>
</v>
<v t="vitalije.20170722122928.1"><vh>Diffing ...</vh>
<v t="vitalije.20170710155333.1"><vh>diff_encoder</vh></v>
<v t="vitalije.20170710155637.1"><vh>encoded_diff</vh></v>
<v t="vitalije.20170710155253.1"><vh>line_transformer</vh></v>
</v>
<v t="ekr.20170719102447.28"></v>
<v t="ekr.20170719102447.10"></v>
</v>
<v t="vitalije.20170721075007.1"><vh>run_experiment</vh></v>
<v t="vitalije.20170721201600.1"><vh>compare_reading_file</vh></v>
<v t="vitalije.20170721201605.1"><vh>compare_reading_all_files</vh></v>
</v>
<v t="vitalije.20170722123231.1"><vh>exp-5 dev @key=Alt-4</vh>
<v t="vitalije.20170721075016.1"></v>
<v t="vitalije.20170722124118.1"><vh>prepare</vh></v>
<v t="vitalije.20170722143839.1"><vh>line_completer</vh></v>
<v t="vitalije.20170722191548.1"><vh>test_160</vh></v>
<v t="vitalije.20170722212234.1"><vh>test_compare_n</vh></v>
<v t="vitalije.20170722215608.1"></v>
<v t="vitalije.20170722201021.1"><vh>test_395</vh></v>
<v t="vitalije.20170722191554.1"><vh>test_160_old</vh></v>
<v t="vitalije.20170722191557.1"><vh>time_test</vh></v>
<v t="vitalije.20170722191602.1"><vh>test_160_new</vh></v>
</v>
<v t="vitalije.20170723144304.1"><vh>exp-6 dev @key=Alt-4</vh>
<v t="vitalije.20170723163600.1"><vh>Utils</vh>
<v t="vitalije.20170723163543.1"><vh>cache - decorator</vh></v>
</v>
<v t="vitalije.20170720214432.1"></v>
<v t="vitalije.20170723145151.1"><vh>experiment-utils</vh>
<v t="vitalije.20170723145133.1"><vh>cls</vh></v>
<v t="vitalije.20170723150719.1"><vh>testfile</vh></v>
<v t="vitalije.20170724231905.1"><vh>profile_this</vh></v>
</v>
<v t="vitalije.20170723144217.1"><vh>p_to_lines</vh>
<v t="vitalije.20170723160205.1"><vh>conf</vh></v>
<v t="vitalije.20170723164028.1"><vh>write patterns</vh></v>
<v t="vitalije.20170723163726.6"><vh>section_ref</vh></v>
<v t="vitalije.20170723163726.10"><vh>others_iterator</vh></v>
<v t="vitalije.20170723163726.11"><vh>section_replacer</vh></v>
<v t="vitalije.20170723163726.13"><vh>open_node</vh></v>
<v t="vitalije.20170723163726.14"><vh>body_lines</vh>
<v t="vitalije.20170723163726.15"><vh>verbatim</vh></v>
<v t="vitalije.20170723163726.16"><vh>first lines &amp; leo header</vh></v>
<v t="vitalije.20170723163726.17"><vh>last lines</vh></v>
</v>
<v t="vitalije.20170723163726.18"><vh>needs_verbatim</vh></v>
<v t="vitalije.20170723163726.19"><vh>others_replacer</vh></v>
<v t="vitalije.20170723163726.20"><vh>atall_replacer</vh></v>
<v t="vitalije.20170723163726.21"><vh>log_it debug iterator</vh></v>
<v t="vitalije.20170723163726.22"><vh>all_lines</vh></v>
<v t="vitalije.20170723163726.23"><vh>at_docer</vh>
<v t="vitalije.20170723163726.24"><vh>at, at-doc</vh></v>
<v t="vitalije.20170723163726.25"><vh>at-c at-code</vh></v>
</v>
<v t="vitalije.20170723163726.26"><vh>at_adder</vh></v>
<v t="vitalije.20170723163726.27"><vh>star_level</vh></v>
<v t="vitalije.20170723171549.1"><vh>sent_line</vh></v>
</v>
<v t="vitalije.20170723144431.1"><vh>test_compare_n</vh></v>
</v>
<v t="vitalije.20170724101826.1"><vh>exp-7 dev @key=Alt-4</vh>
<v t="vitalije.20170720214432.1"></v>
<v t="vitalije.20170723145151.1"></v>
<v t="vitalije.20170724102025.1"><vh>p_to_lines</vh>
<v t="vitalije.20170724102025.2"><vh>conf</vh></v>
<v t="vitalije.20170724102025.3"><vh>write patterns</vh></v>
<v t="vitalije.20170724102025.4"><vh>section_ref</vh></v>
<v t="vitalije.20170724102025.5"><vh>others_iterator</vh></v>
<v t="vitalije.20170724102025.6"><vh>section_replacer</vh></v>
<v t="vitalije.20170724102025.7"><vh>open_node</vh></v>
<v t="vitalije.20170724102025.8"><vh>body_lines</vh>
<v t="vitalije.20170724102025.9"><vh>verbatim</vh></v>
<v t="vitalije.20170724102025.10"><vh>first lines &amp; leo header</vh></v>
<v t="vitalije.20170724102025.11"><vh>last lines</vh></v>
</v>
<v t="vitalije.20170724102025.12"><vh>needs_verbatim</vh></v>
<v t="vitalije.20170724102025.13"><vh>others_replacer</vh></v>
<v t="vitalije.20170724102025.14"><vh>atall_replacer</vh></v>
<v t="vitalije.20170724102025.15"><vh>log_it debug iterator</vh></v>
<v t="vitalije.20170724102025.16"><vh>all_lines</vh></v>
<v t="vitalije.20170724102025.17"><vh>at_docer</vh>
<v t="vitalije.20170724102025.18"><vh>at, at-doc</vh></v>
<v t="vitalije.20170724102025.19"><vh>at-c at-code</vh></v>
</v>
<v t="vitalije.20170724102025.20"><vh>at_adder</vh></v>
<v t="vitalije.20170724102025.21"><vh>star_level</vh></v>
<v t="vitalije.20170724102025.22"><vh>sent_line</vh></v>
</v>
<v t="vitalije.20170724105617.1"><vh>DerivedFileWriter</vh>
<v t="vitalije.20170724110122.1"><vh>birth</vh></v>
<v t="vitalije.20170724110308.1"><vh>others_iterator</vh></v>
<v t="vitalije.20170724110236.1"><vh>section_ref</vh></v>
<v t="vitalije.20170724110403.1"><vh>section_replacer</vh></v>
<v t="vitalije.20170724110553.1"><vh>open_node</vh></v>
<v t="vitalije.20170724110634.1"><vh>body_lines</vh>
<v t="vitalije.20170724110634.2"><vh>verbatim</vh></v>
<v t="vitalije.20170724110634.3"><vh>first lines &amp; leo header</vh></v>
<v t="vitalije.20170724110634.4"><vh>last lines</vh></v>
</v>
<v t="vitalije.20170724110820.1"><vh>needs_verbatim</vh></v>
<v t="vitalije.20170724110849.1"><vh>others_replacer</vh></v>
<v t="vitalije.20170724111016.1"><vh>atall_replacer</vh></v>
<v t="vitalije.20170724111114.1"><vh>log_it debug iterator</vh></v>
<v t="vitalije.20170724112136.1"><vh>all_lines</vh></v>
<v t="vitalije.20170724112249.1"><vh>at_docer</vh>
<v t="vitalije.20170724112249.2"><vh>at, at-doc</vh></v>
<v t="vitalije.20170724112249.3"><vh>at-c at-code</vh></v>
</v>
<v t="vitalije.20170724112531.1"><vh>at_adder</vh></v>
<v t="vitalije.20170724113036.1"><vh>star_level</vh></v>
<v t="vitalije.20170724113053.1"><vh>sent_line</vh></v>
<v t="vitalije.20170724113216.1"><vh>to_lines</vh></v>
</v>
<v t="vitalije.20170723144431.1"></v>
<v t="vitalije.20170724113906.1"><vh>test_compare_n2</vh></v>
<v t="vitalije.20170724105412.1"><vh>test_works_ok</vh></v>
<v t="vitalije.20170724114036.1"><vh>test_works_ok2</vh></v>
<v t="vitalije.20170724105417.1"><vh>profile_this</vh></v>
</v>
<v t="vitalije.20170724122803.1"><vh>exp-8 dev @key=Alt-4</vh>
<v t="vitalije.20170722122928.1"></v>
<v t="vitalije.20170724131900.1"><vh>Utils</vh>
<v t="vitalije.20170724131900.2"><vh>cache - decorator</vh></v>
</v>
<v t="vitalije.20170720214432.1"></v>
<v t="vitalije.20170723145151.1"></v>
<v t="vitalije.20170724133732.1"><vh>load_derived_file</vh>
<v t="vitalije.20170724140140.1"><vh>1. first_lines &amp; header</vh></v>
<v t="vitalije.20170723155348.2"><vh>2. patterns</vh>
<v t="vitalije.20170724214159.1"><vh>get_patterns</vh></v>
</v>
<v t="vitalije.20170724150424.1"><vh>3. top node</vh>
<v t="vitalije.20170724165032.1"><vh>nodes bunch</vh></v>
<v t="vitalije.20170724151357.1"><vh>set_node</vh></v>
<v t="vitalije.20170724151900.1"><vh>doc_skip</vh></v>
<v t="vitalije.20170724165103.1"><vh>start top node</vh></v>
</v>
<v t="vitalije.20170724150825.1"><vh>4. iterate lines</vh>
<v t="vitalije.20170724152531.1"><vh>handle verbatim</vh></v>
<v t="vitalije.20170724195630.1"><vh>handle indent</vh></v>
<v t="vitalije.20170724152616.1"><vh>handle at_all</vh></v>
<v t="vitalije.20170724152800.1"><vh>handle at_others</vh></v>
<v t="vitalije.20170724153641.1"><vh>handle doc</vh></v>
<v t="vitalije.20170724155749.1"><vh>handle_code</vh></v>
<v t="vitalije.20170724162219.1"><vh>handle section ref</vh></v>
<v t="vitalije.20170724162943.1"><vh>handle node_start</vh></v>
<v t="vitalije.20170724170729.1"><vh>handle @-leo</vh></v>
<v t="vitalije.20170724201626.1"><vh>handle directive</vh></v>
<v t="vitalije.20170724203034.1"><vh>handle in_doc</vh></v>
</v>
<v t="vitalije.20170724164635.1"><vh>5. dump nodes</vh></v>
</v>
<v t="vitalije.20170724123641.1"><vh>compare_reading_file</vh></v>
<v t="vitalije.20170724123645.1"><vh>compare_reading_all_files</vh></v>
</v>
<v t="vitalije.20170724203519.1"><vh>writer pattern testing</vh>
<v t="vitalije.20170723155348.2"></v>
</v>
<v t="vitalije.20170720214636.1"><vh>EXTERNALS</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20170719102447.10"></t>
<t tx="ekr.20170719102447.11">def starting_pos():
    pi = c.find_h('@file leoGlobals.py')
    return pi[0] if pi else None</t>
<t tx="ekr.20170719102447.12">def add_ident(n, it):
    wsp = ' '*n
    for w in it:
        yield wsp
        yield w</t>
<t tx="ekr.20170719102447.13">def cut_left(n, it):
    for w in it:
        yield w[n:]</t>
<t tx="ekr.20170719102447.14">def cut_right(n, it):
    for w in it:
        yield w[:n]</t>
<t tx="ekr.20170719102447.15">def section_ref(s):
    i = s.find('&lt;&lt;')
    j = s.find('&gt;&gt;')
    if -1 &lt; i &lt; j:
        s1 = s[i:j+2]
        if s1.startswith('&lt;&lt;&lt;') or g.match(s, j+2, '&gt;'):
            g.es('dubious brackets in', s)
    else:
        s1 = None
    return s1</t>
<t tx="ekr.20170719102447.16">def before_double_gt(s):
    i = s.find('&lt;&lt;')
    return '' if i &lt; 0 else s[:i]</t>
<t tx="ekr.20170719102447.17">def after_str(s, w):
    n = len(w)
    i = s.find(w)
    return s if i &lt; 0 else s[i+n:]</t>
<t tx="ekr.20170719102447.18">class MissingSection(IndexError):
    pass</t>
<t tx="ekr.20170719102447.19">others_pat = re.compile('^(\\s*)@others', re.M)

def others_iterator(p):
    after = p.nodeAfterTree()
    p1 = p.copy().moveToThreadNext()
    while p1 and p1 != after:
        if p1.isAtIgnoreNode() or section_ref(p1.h):
            p1.moveToNodeAfterTree()
        else:
            yield p1.copy()
            if others_pat.search(p1.b):
                p1.moveToNodeAfterTree()
            else:
                p1.moveToThreadNext()
</t>
<t tx="ekr.20170719102447.20">def section_replacer(it, conf):
    for p, w, final in it:
        if conf.verbatim or conf.first or final:
            yield p, w, final
            continue
        sref = section_ref(w)
        if sref and not conf.in_doc:
            if conf.in_all:
                conf.verbatim = True
                yield p, w, False
                conf.verbatim = False
            else:
                indent = before_double_gt(w)
                p1 = g.findReference(sref, p)
                if not p1:
                    raise MissingSection(w)
                yield p, joiner(indent, conf.delim_st, '@+', sref, conf.delim_en, '\n'), True
                for p2, w1, final in all_lines(p1, conf):
                    w1 = indent + w1 if w1 != '\n' else w1
                    yield p2, w1, final
                yield p, joiner(indent, conf.delim_st,
                             '@-', sref, conf.delim_en, after_str(w, sref)), True
                conf.in_doc = False
        else:
            yield p, w, final
</t>
<t tx="ekr.20170719102447.21">def body_lines(p, conf):
    if not conf.first:
        yield p, open_node(p, conf), True
    if p.b:
        for i, line in enumerate(g.splitLines(p.b)):
            # child nodes should use continue
            # if they need to skip following nodes
            @others
            yield p, line, False
        if not line.endswith('\n'):
            yield p, '\n', False
</t>
<t tx="ekr.20170719102447.22">def others_replacer(it, conf):
    for p, w, final in it:
        if conf.verbatim or conf.first or final:
            yield p, w, final
            continue
        m = others_pat.match(w)
        if m and not conf.in_doc:
            if conf.in_all:
                conf.verbatim = True
                yield p, w, False
                conf.verbatim = False
            else:
                indent = m.group(1)
                w1 = joiner(m.group(1), conf.delim_st, '@+others', conf.delim_en, '\n')
                yield p, w1, True
                for p1 in others_iterator(p):
                    for p2, w2, final in all_lines(p1, conf):
                        w2 = indent + w2 if w2 != '\n' else w2
                        yield p2, w2, final
                w1 = joiner(indent, conf.delim_st, '@-others', conf.delim_en, '\n')
                yield p, w1, True
                conf.in_doc = False
        else:
            yield p, w, final</t>
<t tx="ekr.20170719102447.23">def all_lines(p, conf):
    trace = False
    if trace:
        it = body_lines(p, conf)
        it = log_it('body_lines', it)
        it = atall_replacer(it, conf)
        it = log_it('all_repl', it)
        it = section_replacer(it, conf)
        it = log_it('sec_repl', it)
        it = others_replacer(it, conf)
        it = log_it('oth_repl', it)
        it = at_adder(it, conf)
        it = log_it('at_adder', it)
        it = at_docer(it, conf)
        it = log_it('at_docer', it)
    else:
        it = body_lines(p, conf)
        it = atall_replacer(it, conf)
        it = section_replacer(it, conf)
        it = others_replacer(it, conf)
        it = at_adder(it, conf)
        it = at_docer(it, conf)
    return it
</t>
<t tx="ekr.20170719102447.24">doc_pattern = re.compile('^(@doc|@)(?:\\s(.*?)\n|\n)$')
code_pattern = re.compile('^(@code|@c)$')
def at_docer(it, conf):
    for p, w, final in it:
        if conf.verbatim or conf.first or final or conf.in_all:
            yield p, w, final
            continue
        @others
        if conf.in_doc and not conf.delim_en:
            yield p, joiner(conf.delim_st, ' ', w), True
        else:
            yield p, w, False</t>
<t tx="ekr.20170719102447.25">atdir_pat = re.compile('^@(encoding|killbeautify|nosearch|nobeautify|beautify|'
    'last|language|tabwidth|pagewidth|wrap|color|nocolor|nocolor-node|'
    'root|killcolor|path)')

def at_adder(it, conf):
    for p, w, final in it:
        if conf.verbatim or conf.first or final:
            yield p, w, final
            continue
        m = atdir_pat.match(w)
        if m and not conf.in_all:
            if m.group(1) in ('first', 'last'):
                yield p, joiner(conf.delim_st, '@', m.group(0), '\n'), True
            else:
                yield p, joiner(conf.delim_st, '@', w[:-1], conf.delim_en, '\n'), True
        else:
            yield p, w, False</t>
<t tx="ekr.20170719102447.26">def star_level(lev):
    if lev &lt; 2:
        return [': * ', ': ** '][lev]
    else:
        return ': *%d* '%(lev + 1)</t>
<t tx="ekr.20170719102447.28"></t>
<t tx="ekr.20170719102447.29">def node_start_lines(data):
    flines, ptrns, verbatims = data
    pat = ptrns.node_start

    for i, line in flines:
        if i in verbatims: continue

        m = at_node_start(i, line, pat)
        if m:
            yield m
</t>
<t tx="ekr.20170719102447.30">def at_node_start(i, line, pat):
    m = pat.match(line)
    if m:
        if m.group(3):
            level = int(m.group(3)) #levelNo
        elif m.group(4): #second_star
            level = 2
        else:
            level = 1
        return (i, # line no
                m.group(1), #indent
                m.group(2), #gnx
                level,
                m.group(5)) #headline
    else:
        return False</t>
<t tx="ekr.20170719102447.32">def at_others_refs(data):
    flines, ptrns, verbatims = data
    pat = ptrns.others
    starts = []

    for i, line in flines:

        if i in verbatims: continue

        m = match_at_others(i, line, pat)

        if m and m[2]:
            starts.append(m)
        elif m:
            j, indent, junk = starts.pop()
            yield j, i, indent

</t>
<t tx="ekr.20170719102447.33">def body_lines_of_node(gnx, analytics):
    a = analytics; delim_st = a.delim_st

    in_doc = False
    verbatim = delim_st + '@verbatim'
    in_verbatim = False

    for line in body_raw_lines_of_node(gnx, analytics):
        @others
        # or ordinary lines
        if in_doc:
            if not line.startswith(delim_st):
                yield line
            else:
                yield line[len(delim_st)+1:]
        else:
            yield line
</t>
<t tx="ekr.20170719102447.34">def body_raw_lines_of_node(gnx, analytics):
    a = analytics; flines = a.flines; verbatims = a.verbatims
    st, lev, h, ind = a.nodes[gnx][0]
    node_end = end_of_node(gnx, analytics)
    i  = st + 1 # line after at+node
    # is node inside at-all directive?
    all_ij= find_all(i, a.atall)
    in_raw = False
    atraw_st = a.delim_st + '@@raw' + a.delim_en
    atraw_end = a.delim_st + '@@raw_end' + a.delim_en
    while i &lt; node_end:
        @others
</t>
<t tx="ekr.20170719102447.35">def check_at_doc(line, delim_st):
    if line.startswith(delim_st):
        rl = line[len(delim_st):]
        if rl.startswith(('@+at\n', '@+at ')):
            return True, '@' + rl[4:]
        elif rl.startswith(('@+doc ', '@+doc\n')):
            return True, '@' + rl[2:]
    return False, line</t>
<t tx="ekr.20170719102447.36">def check_at_code(line, delim_st):
    if line.startswith(delim_st):
        rl = line[len(delim_st):]
        if rl.startswith(('@@c\n', '@@code\n')):
            return True, rl[1:]
        elif rl.startswith('@@'):
            return False, strip_end_delimiter(rl[1:], delim_st)
    return False, line

</t>
<t tx="ekr.20170719102447.37">def body_lines_of_top_node(gnx, analytics):
    a = analytics; delim_st = a.delim_st

    first_lines = list(read_at_first_lines(analytics))
    last_lines = list(read_at_last_lines(analytics))

    leo_end = delim_st + '@-leo'

    for line in body_lines_of_node(gnx, analytics):

        if line.startswith(leo_end):
            continue # skip end of file sentinel
        elif line.startswith('@first'):
            assert first_lines, repr(first_lines)
            # insert first line
            yield line[:6] + ' ' + first_lines.pop(0)
        elif line.startswith('@last'):
            assert last_lines, repr(last_lines)
            # insert last line
            yield line[:5] + ' ' + last_lines.pop(0)
        else:
            yield line</t>
<t tx="ekr.20170719102447.38">def end_of_node(gnx, analytics):

    a = analytics

    st, lev, h, ind = a.nodes[gnx][0]

    is_inside = lambda x:st &gt; x[0] and st &lt; x[1]
    in_all = next(filter(is_inside, a.atall),  False)

    if in_all:
        end_all = in_all[1]
        res = end_of_node_in_all(st, end_all, analytics)

    elif st - 1 in a.sects:
        # inside section node: end is at the end of section
        res = a.sects[st-1][0]

    else:
        # not in all, not in section
        # must be in at-others
        res = end_of_node_in_others(st, lev, analytics)

    return res
</t>
<t tx="ekr.20170719102447.39">def analyze_lines(lines):
    flines = tuple(enumerate(lines))
    @others
    return g.bunch(
            flines = flines,
            nodes = node_data,
            nstart = node_starts,
            sects = sect_data,
            othrs = at_oth_data,
            oend = oth_ends,
            delim_st = delim_st,
            delim_en = delim_en,
            verbatims = verbatims,
            atall = at_all_data,)

</t>
<t tx="ekr.20170719102447.40">def children_gnxes(gnx, analytics):
    a = analytics; node_data = a.nodes
    st, level, h, wsp = node_data.get(gnx)[0]
    i = st + 1 # start after at+node sentinel
    tlevel = level + 1 # target level we are looking for
    while i &lt; len(flines):
        ignx = a.nstart.get(i)
        if ignx:
            ilev = node_data.get(ignx)[0][1]
            if ilev == tlevel:
                yield ignx
            elif ilev &lt; tlevel:
                break
        i += 1</t>
<t tx="ekr.20170719102447.41">def gnx2headline(gnx, analytics):
    a = analytics
    return a.nodes[gnx][0][2]</t>
<t tx="ekr.20170719102447.42">def read_at_first_lines(analytics):
    a = analytics
    for i, line in a.flines:
        if leo_header_pat.match(line):
            # first lines are only before at+leo
            break
        yield line
</t>
<t tx="vitalije.20170710155253.1">def line_transformer(lines, codes):
    i = 0; n = len(codes)
    j = 0
    while j &lt; n:
        code = codes[j][0]
        arg = codes[j][1:]
        j += 1
        if code == 's':
            i += int(arg)
        elif code == 'r':
            yield arg
            i += 1
        elif code == 'c':
            for k in range(int(arg)):
                yield lines[i]
                i += 1
        elif code == 'i':
            yield arg

</t>
<t tx="vitalije.20170710155333.1">def diff_encoder(a, b):
    sm = difflib.SequenceMatcher(a=a, b=b, autojunk=False)
    i = 0; j = 0
    for bl in sm.get_matching_blocks():
        if (bl.a - i) == (bl.b - j) and (bl.a &gt; i):
            while bl.a &gt; i:
                yield 'r%s'%b[j]
                i += 1
                j += 1
        else:
            if bl.a &gt; i:
                yield 's%d\n'%(bl.a - i)
                i = bl.a
            while bl.b &gt; j:
                yield 'i%s'%b[j]
                j += 1
        if bl.size:
            yield 'c%d\n'%bl.size
            i += bl.size
            j += bl.size
</t>
<t tx="vitalije.20170710155637.1">def encoded_diff(a, b):
    '''Returns encoded diff between strings a and b.
       Returned diff contains one opcode per line.
       Opcodes when combined with lines from a
       using line_transformer give lines of b.'''
    aa = g.splitLines(a)
    bb = g.splitLines(b)
    return ''.join(diff_encoder(aa, bb))
</t>
<t tx="vitalije.20170720180020.1">import itertools
import re
import leo.core.leoNodes as leoNodes
c.frame.log.selectTab('Log')
c.frame.log.clearLog()
@others
p = c.find_h('EXTERNALS')[0]
if not p.hasChildren():
    do_import_file(149)
    c.redraw()
p.moveToFirstChild()
import timeit
def test_lines_enumerator():
    n = f_line_numerate(p.copy(), 1, True)
num = 100
t = timeit.timeit(test_lines_enumerator, number=num)
g.es(t/num, 'seconds')

with_sentinels = p.h.startswith(('@file ', '@thin '))
try:
    n = f_line_numerate(p, 1, with_sentinels)
except Exception as e:
    g.es_exception(e)
    g.traceback.print_exc()
g.es('enumerated last line', n)
to_display = ['ekr.20031218072017.2608',
              'ekr.20120219194520.10463',
              'ekr.20161026122804.1',
              'ekr.20161026125611.1',
              'ekr.20161026124810.1',
              'ekr.20120209051836.10241',
              'ekr.20031218072017.1416',
              'ekr.20161028035755.1',
              'ekr.20050424131051',
              'ekr.20150514125218.5'
              ]
for gnx in to_display:
    v = c.fileCommands.gnxDict[gnx]
    g.es(v.h)
    for n, line in zip(v.f_lines, v.lines):
        if line == v.lines[0] or line == v.lines[-1]:
            g.es('---', n, line.rstrip())
        </t>
<t tx="vitalije.20170720181045.1">def vnode_get_lines(v):
    if hasattr(v,'_prevBody') and v._prevBody == v._bodyString:
        return v._lines
    else:
        v._prevBody = v._bodyString
        v._lines = tuple(g.splitLines(v._bodyString))
    return v._lines
leoNodes.VNode.lines = property(vnode_get_lines)</t>
<t tx="vitalije.20170720181053.1">def f_line_numerate(p, start=1, with_sentinels=True):
    f_lines = []
    n = start; check_first = start == 1
    inc = lambda x:x + 1 if with_sentinels else x
    nf = 0
    if start &gt; 1:
        n = inc(n)
    for line in p.v.lines:
        if check_first and line.startswith('@first '):
            f_lines.append(n)
            n += 1
            nf += 1
            continue
        if check_first and with_sentinels:
            n += 2 + nf
        check_first = False
        f_lines.append(n)
        sref = section_ref(line)
        if sref:
            p1 = g.findReference(sref, p)
            if not p1:
                raise MissingSection(line)
            n = inc(n)
            n = f_line_numerate(p1, n, with_sentinels)
            n = inc(n)
            continue
        if others_pat.match(line):
            n = inc(n)
            for p1 in others_iterator(p):
                n = f_line_numerate(p1, n, with_sentinels)
            n = inc(n)
            continue
        if with_sentinels or not g.isDirective(line):
            n += 1
    p.v.f_lines = tuple(f_lines)
    return inc(n) if start==1 else n
</t>
<t tx="vitalije.20170720182924.1">one_line_directives = '''
beautify colorcache code color comment c delims doc encoding end_raw first
header ignore killbeautify killcolor language last lineending markup
nobeautify nocolor-node nocolor noheader nowrap nosearch pagewidth path raw
quiet root-code root-doc root silent tabwidth unit terse verbose wrap'''.split()
one_line_directives = tuple('@'+x for x in one_line_directives)</t>
<t tx="vitalije.20170720190022.1">def vnode_total_lines(p, with_sentinels=True):
    n = 0
    for line in p.v.lines:
        n += vnode_how_many_from_this_line(p, line, with_sentinels)
    return n
</t>
<t tx="vitalije.20170720190205.1">def vnode_has_others(v):
    for x in v.lines:
        if others_pat.match(x):
            return True
    else:
        return False
leoNodes.VNode.has_others = property(vnode_has_others)
</t>
<t tx="vitalije.20170720192016.1">def vnode_how_many_from_this_line(p, line, with_sentinels=True):
    sref = section_ref(line)
    if sref:
        p1 = g.findReference(sref, p)
        if not p1:
            raise MissingSection(sref)
        return 2 + vnode_total_lines(p1, with_sentinels)
    elif others_pat.match(line):
        n = 2
        for p1 in others_iterator(p):
            n += vnode_total_lines(p1, with_sentinels)
    elif g.isDirective(line) and not with_sentinels:
        return 0
    else:
        return 1</t>
<t tx="vitalije.20170720194135.1">def vnode_f_lines(p, start=0, with_sentinels=True):
    if with_sentinels:
        return vnode_f_lines_with_sentinels(p, start)
    n = start
    for i, line in enumerate(p.v.lines):
        yield n
        n += vnode_how_many_from_this_line(p, line, False)

def vnode_f_lines_with_sentinels(p, start):
    n = start + 1
    first = 1
    for i, line in enumerate(p.v.lines):
        if line.startswith('@first '):
            yield first
            first += 1
            n += 1
        else:
            yield n
            n += vnode_how_many_for_this_line(p, line, True)</t>
<t tx="vitalije.20170720214432.1"></t>
<t tx="vitalije.20170720214432.10">def scan_for_ideal_import():
    res = {}
    for j,fn in enumerate(derived_files):
        if j in false_positives: continue
        pfi = path_for_ideal_import(j)
        assert pfi.startswith(('@file ', '@thin '))
        assert fn.startswith(g.app.leoDir)
        fn = fn[len(g.app.leoDir)-3:]
        res[fn] = pfi[6:].strip()
    return res</t>
<t tx="vitalije.20170720214432.11">def try_import_file(j):
    if j in false_positives: return True
    ok = False
    try:
        result = do_import_file(j)
        if result:
            ok, p2 = result
        else:
            ok, p2 = False, None
    finally:
        if p2:
            p2.doDelete()
    return ok
</t>
<t tx="vitalije.20170720214432.12">def clear_gnxDict():
    valid_gnxes = set(v.gnx for v in c.all_unique_nodes())
    all_gnxes = set(x for x in c.fileCommands.gnxDict.keys())
    invalid = all_gnxes.difference(valid_gnxes)
    # g.es(len(valid_gnxes), len(all_gnxes), len(invalid))
    for gnx in invalid:
        c.fileCommands.gnxDict.pop(gnx)


</t>
<t tx="vitalije.20170720214432.13">def can_import_every_derived_file():
    errs = set()
    try:
        log = g.app.log
        g.unitTesting = True
        for i in range(len(derived_files)):
            ok = try_import_file(i)
            s = '.' if ok else 'E'
            if i % 35 == 34:
                log.put(s + '\n')
            else:
                log.put(s)
            if ok: continue
            errs.add(i)
    finally:
        g.unitTesting = False
        g.es('\n')
    clear_gnxDict()
    if errs:
        g.es(errs)
    return not errs</t>
<t tx="vitalije.20170720214432.14">def test_1():
    if can_import_every_derived_file():
        g.es('ok')
    else:
        g.es("some files can't be imported\nSee log.")</t>
<t tx="vitalije.20170720214432.2">derived_files = ('''%(leo)s/doc/leoProjects.txt
%(leo)s/doc/leoAttic.txt
%(leo)s/doc/release_notes.txt
%(leo)s/doc/leoUserGuide.txt
%(leo)s/doc/leoBridge.txt
%(leo)s/doc/zodb.txt
%(leo)s/doc/running.txt
%(leo)s/doc/slideshows.txt
%(leo)s/doc/leoandotherprograms.txt
%(leo)s/doc/testimonials.txt
%(leo)s/doc/leoToDo.txt
%(leo)s/doc/vimBindings.txt
%(leo)s/doc/usersguide.txt
%(leo)s/doc/whatsnew.txt
%(leo)s/doc/slides.txt
%(leo)s/doc/rstplugin3.txt
%(leo)s/doc/debuggers.txt
%(leo)s/doc/customizing.txt
%(leo)s/doc/LeoDocs.leo
%(leo)s/doc/appendices.txt
%(leo)s/doc/unitTesting.txt
%(leo)s/doc/LeoReleaseNotes.leo
%(leo)s/doc/leoToDoLater.txt
%(leo)s/doc/nutshell.txt
%(leo)s/doc/design.txt
%(leo)s/doc/cheatsheet.txt
%(leo)s/doc/preface.txt
%(leo)s/doc/outline-commands.txt
%(leo)s/doc/leoSlideShows.leo
%(leo)s/doc/intermediatetopics.txt
%(leo)s/doc/preliminaries.txt
%(leo)s/doc/download.txt
%(leo)s/doc/leoNotes.txt
%(leo)s/doc/FAQ.txt
%(leo)s/doc/html/index.html
%(leo)s/doc/frontMatter.txt
%(leo)s/doc/glossary.txt
%(leo)s/doc/atShadow.txt
%(leo)s/doc/plugin_catalog.py
%(leo)s/doc/coloring.txt
%(leo)s/doc/intro.txt
%(leo)s/doc/screen-shots.txt
%(leo)s/doc/plugins.txt
%(leo)s/doc/outlines.txt
%(leo)s/doc/commands.txt
%(leo)s/doc/IpythonBridge.txt
%(leo)s/doc/emacs.txt
%(leo)s/doc/sphinx-docs/leo.rst
%(leo)s/doc/sphinx-docs/index.rst
%(leo)s/doc/sphinx-docs/requirements.txt
%(leo)s/doc/sphinx-docs/leo.plugins.pygeotag.rst
%(leo)s/doc/sphinx-docs/leo.plugins.rst
%(leo)s/doc/sphinx-docs/leo.external.rst
%(leo)s/doc/sphinx-docs/leo.external.concurrent.rst
%(leo)s/doc/sphinx-docs/Makefile
%(leo)s/doc/sphinx-docs/make.bat
%(leo)s/doc/sphinx-docs/leo.core.rst
%(leo)s/doc/sphinx-docs/leo.external.concurrent.futures.rst
%(leo)s/doc/sphinx-docs/conf.py
%(leo)s/doc/sphinx-docs/leo.extensions.rst
%(leo)s/doc/tutorial.txt
%(leo)s/doc/writingPlugins.txt
%(leo)s/doc/installing.txt
%(leo)s/scripts/build-leo.bat
%(leo)s/scripts/tangle_done.py
%(leo)s/scripts/unregister-leo.leox
%(leo)s/scripts/register-leo.leox
%(leo)s/scripts/elevate.py
%(leo)s/scripts/gen_blender_docs.py
%(leo)s/scripts/leoScripts.txt
%(leo)s/scripts/untangle_done.py
%(leo)s/scripts/leoFindScript.py
%(leo)s/external/obsolete/ipy_leo.py
%(leo)s/external/lproto.py
%(leo)s/external/npyscreen/npysNPSFilteredData.py
%(leo)s/external/npyscreen/wgboxwidget.py
%(leo)s/external/npyscreen/proto_fm_screen_area.py
%(leo)s/external/npyscreen/wgeditmultiline.py
%(leo)s/external/npyscreen/wgtexttokens.py
%(leo)s/external/npyscreen/npyssafewrapper.py
%(leo)s/external/npyscreen/wgtextbox_controlchrs.py
%(leo)s/external/npyscreen/npysThemes.py
%(leo)s/external/npyscreen/apNPSApplication.py
%(leo)s/external/npyscreen/wgwidget_proto.py
%(leo)s/external/npyscreen/wgautocomplete.py
%(leo)s/external/npyscreen/wgtextbox.py
%(leo)s/external/npyscreen/apNPSApplicationManaged.py
%(leo)s/external/npyscreen/wgNMenuDisplay.py
%(leo)s/external/npyscreen/wgpassword.py
%(leo)s/external/npyscreen/fmFormMultiPage.py
%(leo)s/external/npyscreen/globals.py
%(leo)s/external/npyscreen/wgmultilinetreeselectable.py
%(leo)s/external/npyscreen/wggridcoltitles.py
%(leo)s/external/npyscreen/apNPSApplicationEvents.py
%(leo)s/external/npyscreen/eveventhandler.py
%(leo)s/external/npyscreen/npysTree.py
%(leo)s/external/npyscreen/wgtitlefield.py
%(leo)s/external/npyscreen/npysThemeManagers.py
%(leo)s/external/npyscreen/fm_form_edit_loop.py
%(leo)s/external/npyscreen/__init__.py
%(leo)s/external/npyscreen/fmActionFormV2.py
%(leo)s/external/npyscreen/wgselectone.py
%(leo)s/external/npyscreen/npyspmfuncs.py
%(leo)s/external/npyscreen/fmFormMuttActive.py
%(leo)s/external/npyscreen/wgmonthbox.py
%(leo)s/external/npyscreen/apNPSApplicationAdvanced.py
%(leo)s/external/npyscreen/fmFileSelector.py
%(leo)s/external/npyscreen/wgcombobox.py
%(leo)s/external/npyscreen/wgmultilinetree.py
%(leo)s/external/npyscreen/muMenu.py
%(leo)s/external/npyscreen/utilNotify.py
%(leo)s/external/npyscreen/wgmultilineeditable.py
%(leo)s/external/npyscreen/fmFormMutt.py
%(leo)s/external/npyscreen/wgcheckbox.py
%(leo)s/external/npyscreen/wgwidget.py
%(leo)s/external/npyscreen/wgslider.py
%(leo)s/external/npyscreen/apOptions.py
%(leo)s/external/npyscreen/wgmultiselect.py
%(leo)s/external/npyscreen/fmFormWithMenus.py
%(leo)s/external/npyscreen/muNewMenu.py
%(leo)s/external/npyscreen/wgFormControlCheckbox.py
%(leo)s/external/npyscreen/fmActionForm.py
%(leo)s/external/npyscreen/util_viewhelp.py
%(leo)s/external/npyscreen/wggrid.py
%(leo)s/external/npyscreen/wgfilenamecombo.py
%(leo)s/external/npyscreen/fmPopup.py
%(leo)s/external/npyscreen/wgmultiline.py
%(leo)s/external/npyscreen/wgmultiselecttree.py
%(leo)s/external/npyscreen/wgbutton.py
%(leo)s/external/npyscreen/wgdatecombo.py
%(leo)s/external/npyscreen/wgannotatetextbox.py
%(leo)s/external/npyscreen/npysGlobalOptions.py
%(leo)s/external/npyscreen/wgtextboxunicode.py
%(leo)s/external/npyscreen/stdfmemail.py
%(leo)s/external/npyscreen/fmForm.py
%(leo)s/external/stringlist.py
%(leo)s/external/leosax.py
%(leo)s/external/log_listener.py
%(leo)s/external/sax2db.py
%(leo)s/external/edb.py
%(leo)s/external/py2cs.py
%(leo)s/external/make_stub_files.py
%(leo)s/external/log_broadcast.py
%(leo)s/external/codewise.py
%(leo)s/external/leoSAGlobals.py
%(leo)s/core/format-code.py
%(leo)s/core/leoImport.py
%(leo)s/core/leoPrinting.py
%(leo)s/core/leoBridgeTest.py
%(leo)s/core/leoApp.py
%(leo)s/core/leoUndo.py
%(leo)s/core/leoDynamicTest.py
%(leo)s/core/leoFileCommands.py
%(leo)s/core/leoTangle.py
%(leo)s/core/leoTest.py
%(leo)s/core/leoVim.py
%(leo)s/core/leoQt.py
%(leo)s/core/leoIPython.py
%(leo)s/core/leoCompare.py
%(leo)s/core/leoSessions.py
%(leo)s/core/leoGlobals.py
%(leo)s/core/leoFind.py
%(leo)s/core/leoMenu.py
%(leo)s/core/leoCheck.py
%(leo)s/core/leoGui.py
%(leo)s/core/leoBackground.py
%(leo)s/core/leoPlugins.py
%(leo)s/core/leoAst.py
%(leo)s/core/leoNodes.py
%(leo)s/core/leoCommands.py
%(leo)s/core/leoHistory.py
%(leo)s/core/leoVersion.py
%(leo)s/core/leoPersistence.py
%(leo)s/core/leoConfig.py
%(leo)s/core/leoCache.py
%(leo)s/core/leoRst.py
%(leo)s/core/leoBeautify.py
%(leo)s/core/leoPymacs.py
%(leo)s/core/leoExternalFiles.py
%(leo)s/core/leoChapters.py
%(leo)s/core/leoAtFile.py
%(leo)s/core/leoKeys.py
%(leo)s/core/leoShadow.py
%(leo)s/core/buttons.txt
%(leo)s/core/runLeo.py
%(leo)s/core/leoColorizer.py
%(leo)s/core/test_core.txt
%(leo)s/core/leoBridge.py
%(leo)s/core/key-handling-notes.txt
%(leo)s/core/leoDebugger.py
%(leo)s/core/leoColor.py
%(leo)s/core/leoFrame.py
%(leo)s/core/leoRope.py
%(leo)s/extensions/testExtension.py
%(leo)s/extensions/colors.py
%(leo)s/plugins/mod_speedups.py
%(leo)s/plugins/obsolete/ironPythonGui.py
%(leo)s/plugins/obsolete/gtkGui.py
%(leo)s/plugins/obsolete/gtkDialogs.py
%(leo)s/plugins/obsolete/swing_gui.py
%(leo)s/plugins/obsolete/tkGui.py
%(leo)s/plugins/obsolete/wxGui.py
%(leo)s/plugins/qt_frame.py
%(leo)s/plugins/ctagscompleter.py
%(leo)s/plugins/leomylyn.py
%(leo)s/plugins/ftp.py
%(leo)s/plugins/nodewatch.py
%(leo)s/plugins/nested_splitter.py
%(leo)s/plugins/macros.py
%(leo)s/plugins/livecode.py
%(leo)s/plugins/interact.py
%(leo)s/plugins/multifile.py
%(leo)s/plugins/slideshow.py
%(leo)s/plugins/notebook.py
%(leo)s/plugins/leoPluginNotes.txt
%(leo)s/plugins/sftp.py
%(leo)s/plugins/screenshots.py
%(leo)s/plugins/plugins_menu.py
%(leo)s/plugins/xml_edit.py
%(leo)s/plugins/outline_export.py
%(leo)s/plugins/startfile.py
%(leo)s/plugins/graphcanvas.py
%(leo)s/plugins/scripts_menu.py
%(leo)s/plugins/quicksearch.py
%(leo)s/plugins/viewrendered2.py
%(leo)s/plugins/qt_text.py
%(leo)s/plugins/template_gui.py
%(leo)s/plugins/colorize_headlines.py
%(leo)s/plugins/python_terminal.py
%(leo)s/plugins/stickynotes.py
%(leo)s/plugins/runGtkDialogs.py.txt
%(leo)s/plugins/qt_tree.py
%(leo)s/plugins/demo.py
%(leo)s/plugins/setHomeDirectory.py
%(leo)s/plugins/nodetags.py
%(leo)s/plugins/script_io_to_body.py
%(leo)s/plugins/auto_colorize2_0.py
%(leo)s/plugins/leo_to_rtf.py
%(leo)s/plugins/chapter_hoist.py
%(leo)s/plugins/xemacs.py
%(leo)s/plugins/niceNosent.py
%(leo)s/plugins/word_count.py
%(leo)s/plugins/quickMove.py
%(leo)s/plugins/tomboy_import.py
%(leo)s/plugins/mod_read_dir_outline.py
%(leo)s/plugins/qt_gui.py
%(leo)s/plugins/timestamp.py
%(leo)s/plugins/leomail.py
%(leo)s/plugins/expfolder.py
%(leo)s/plugins/dtest.py
%(leo)s/plugins/xsltWithNodes.py
%(leo)s/plugins/rss.py
%(leo)s/plugins/bzr_qcommands.py
%(leo)s/plugins/leo_interface.py
%(leo)s/plugins/leofeeds.py
%(leo)s/plugins/pluginsNotes.txt
%(leo)s/plugins/at_produce.py
%(leo)s/plugins/leoremote.py
%(leo)s/plugins/mod_scripting.py
%(leo)s/plugins/mod_autosave.py
%(leo)s/plugins/run_nodes.py
%(leo)s/plugins/todo.py
%(leo)s/plugins/markup_inline.py
%(leo)s/plugins/importers/python.py
%(leo)s/plugins/importers/ini.py
%(leo)s/plugins/importers/coffeescript.py
%(leo)s/plugins/importers/typescript.py
%(leo)s/plugins/importers/csharp.py
%(leo)s/plugins/importers/linescanner.py
%(leo)s/plugins/importers/ipynb.py
%(leo)s/plugins/importers/leo_rst.py
%(leo)s/plugins/importers/__init__.py
%(leo)s/plugins/importers/java.py
%(leo)s/plugins/importers/xml.py
%(leo)s/plugins/importers/markdown.py
%(leo)s/plugins/importers/c.py
%(leo)s/plugins/importers/javascript.py
%(leo)s/plugins/importers/dart.py
%(leo)s/plugins/importers/perl.py
%(leo)s/plugins/importers/pascal.py
%(leo)s/plugins/importers/php.py
%(leo)s/plugins/importers/html.py
%(leo)s/plugins/importers/org.py
%(leo)s/plugins/importers/lua.py
%(leo)s/plugins/importers/otl.py
%(leo)s/plugins/importers/elisp.py
%(leo)s/plugins/importers/json.py
%(leo)s/plugins/importers/tcl.py
%(leo)s/plugins/importers/ctext.py
%(leo)s/plugins/mod_timestamp.py
%(leo)s/plugins/gitarchive.py
%(leo)s/plugins/dump_globals.py
%(leo)s/plugins/mod_leo2ascd.txt
%(leo)s/plugins/screencast.py
%(leo)s/plugins/debugger_pudb.py
%(leo)s/plugins/qt_commands.py
%(leo)s/plugins/vnodes-history.py
%(leo)s/plugins/writers/basewriter.py
%(leo)s/plugins/writers/ipynb.py
%(leo)s/plugins/writers/leo_rst.py
%(leo)s/plugins/writers/__init__.py
%(leo)s/plugins/writers/markdown.py
%(leo)s/plugins/writers/dart.py
%(leo)s/plugins/writers/test.py
%(leo)s/plugins/writers/org.py
%(leo)s/plugins/writers/otl.py
%(leo)s/plugins/writers/json.py
%(leo)s/plugins/writers/ctext.py
%(leo)s/plugins/pretty_print.py
%(leo)s/plugins/stickynotes_plus.py
%(leo)s/plugins/viewrendered.py
%(leo)s/plugins/mod_http.py
%(leo)s/plugins/at_view.py
%(leo)s/plugins/trace_gc_plugin.py
%(leo)s/plugins/bookmarks.py
%(leo)s/plugins/projectwizard.py
%(leo)s/plugins/jinjarender.py
%(leo)s/plugins/qtGui.py
%(leo)s/plugins/keys.css
%(leo)s/plugins/read_only_nodes.py
%(leo)s/plugins/pyplot_backend.py
%(leo)s/plugins/pluginsManager.txt
%(leo)s/plugins/rst3.py
%(leo)s/plugins/contextmenu.py
%(leo)s/plugins/import_cisco_config.py
%(leo)s/plugins/cursesGui.py
%(leo)s/plugins/dragdropgoodies.py
%(leo)s/plugins/add_directives.py
%(leo)s/plugins/leocursor.py
%(leo)s/plugins/empty_leo_file.py
%(leo)s/plugins/testRegisterCommand.py
%(leo)s/plugins/datenodes.py
%(leo)s/plugins/bigdash.py
%(leo)s/plugins/qtNotes.txt
%(leo)s/plugins/at_folder.py
%(leo)s/plugins/leoscreen.py
%(leo)s/plugins/backlink.py
%(leo)s/plugins/open_shell.py
%(leo)s/plugins/qt_idle_time.py
%(leo)s/plugins/maximizeNewWindows.py
%(leo)s/plugins/test/failed_import.py
%(leo)s/plugins/test/failed_to_load_plugin.py
%(leo)s/plugins/test/syntax_error_plugin.py
%(leo)s/plugins/test/ekr_test.py
%(leo)s/plugins/trace_tags.py
%(leo)s/plugins/free_layout.py
%(leo)s/plugins/nodeActions.py
%(leo)s/plugins/cursesGui2.py
%(leo)s/plugins/spydershell.py
%(leo)s/plugins/leoOPML.py
%(leo)s/plugins/nodediff.py
%(leo)s/plugins/threadutil.py
%(leo)s/plugins/leo_to_html.py
%(leo)s/plugins/baseNativeTree.py
%(leo)s/plugins/initinclass.py
%(leo)s/plugins/redirect_to_log.py
%(leo)s/plugins/enable_gc.py
%(leo)s/plugins/attrib_edit.py
%(leo)s/plugins/FileActions.py
%(leo)s/plugins/trace_keys.py
%(leo)s/plugins/mime.py
%(leo)s/plugins/wikiview.py
%(leo)s/plugins/bibtex.py
%(leo)s/plugins/mod_leo2ascd.py
%(leo)s/plugins/settings_finder.py
%(leo)s/plugins/systray.py
%(leo)s/plugins/tables.py
%(leo)s/plugins/geotag.py
%(leo)s/plugins/mnplugins.py
%(leo)s/plugins/zenity_file_dialogs.py
%(leo)s/plugins/richtext.py
%(leo)s/plugins/examples/override_classes.py
%(leo)s/plugins/examples/redefine_put.py
%(leo)s/plugins/examples/chinese_menu.py
%(leo)s/plugins/examples/print_cp.py
%(leo)s/plugins/examples/french_fm.py
%(leo)s/plugins/examples/override_commands.py
%(leo)s/plugins/screen_capture.py
%(leo)s/plugins/qt_quickheadlines.py
%(leo)s/plugins/quit_leo.py
%(leo)s/plugins/vim.py
%(leo)s/plugins/codewisecompleter.py
%(leo)s/plugins/nav_qt.py
%(leo)s/plugins/qt_events.py
%(leo)s/plugins/leo_pdf.py
%(leo)s/plugins/textnode.py
%(leo)s/plugins/mod_framesize.py
%(leo)s/plugins/paste_as_headlines.py
%(leo)s/plugins/valuespace.py
%(leo)s/plugins/word_export.py
%(leo)s/plugins/active_path.py
%(leo)s/plugins/lineNumbers.py
%(leo)s/dist/setup.py
%(leo)s/test/inactiveTests.txt
%(leo)s/test/test.leo
%(leo)s/test/activeUnitTests.txt
%(leo)s/test/unittest/at-thin-line-number-test.py
%(leo)s/test/unittest/at-noref-test.py
%(leo)s/test/unittest/batchTest.py
%(leo)s/test/unittest/at-path-test1.py
%(leo)s/test/unittest/at-path-test3.py
%(leo)s/test/unittest/at-path-test2.py
%(leo)s/test/unittest/at-file-line-number-test.py
%(leo)s/test/unittest/at-thin-test.py
%(leo)s/test/unittest/at-thin-html-test.html
%(leo)s/test/unittest/tex-error.tex
%(leo)s/test/unittest/at-file-test.py
%(leo)s/test/unittest/input/cweave.w
%(leo)s/test/unittest/input/testLeoAtFile.py
%(leo)s/test/unittest/at-file-thin-test2.txt
%(leo)s/test/unittest/at-file-line-number-test.c
%(leo)s/test/unittest/errorTest.py
%(leo)s/test/cgi-bin/edward.py
%(leo)s/test/cgi-bin/leo.js
%(leo)s/test/unitTestStartup.txt
%(leo)s/commands/killBufferCommands.py
%(leo)s/commands/baseCommands.py
%(leo)s/commands/convertCommands.py
%(leo)s/commands/abbrevCommands.py
%(leo)s/commands/controlCommands.py
%(leo)s/commands/searchCommands.py
%(leo)s/commands/spellCommands.py
%(leo)s/commands/gotoCommands.py
%(leo)s/commands/checkerCommands.py
%(leo)s/commands/debugCommands.py
%(leo)s/commands/helpCommands.py
%(leo)s/commands/keyCommands.py
%(leo)s/commands/bufferCommands.py
%(leo)s/commands/rectangleCommands.py
%(leo)s/commands/editFileCommands.py
%(leo)s/commands/editCommands.py'''%{'leo': g.app.leoDir}).splitlines(False)</t>
<t tx="vitalije.20170720214432.3">false_positives = frozenset(
    [    3,  18,  21,  28,  64,  70,  71, 135, 138, # 138 is part of sqlite-leo branch
       183, 186, 188, 193, 194, 197, 198, 230, 255, 296, # 296 is vnodes-history.py
       318, 321, 394, 397, 406, 407, 408, 409, 412,
       413])
# 296, 138 are not part of official leo distribution</t>
<t tx="vitalije.20170720214432.4">def show_derived_files_statistics():
    g.es('number of derived files:', len(derived_files))
    all_delims = set()
    all_versions = set()
    all_trailings = set()
    for j,fn in enumerate(derived_files[0:450]):
        if j in false_positives: continue
        lines = get_lines(j)
        for i, line in enumerate(lines):
            m = at_leo_start_pat.match(line)
            if m:
                delim = m.group(1)
                all_delims.add(delim)
                ver = m.group(2)
                all_versions.add(ver.strip())
                tc = m.group(3).strip()
                all_trailings.add(tc)
                break
    g.es('all_delims', all_delims)
    g.es('all_versions', all_versions)
    g.es('all_trailings', all_trailings)</t>
<t tx="vitalije.20170720214432.5">paths_data = {
 'leo/commands/abbrevCommands.py': '../commands/abbrevCommands.py',
 'leo/commands/baseCommands.py': '../commands/baseCommands.py',
 'leo/commands/bufferCommands.py': '../commands/bufferCommands.py',
 'leo/commands/checkerCommands.py': '../commands/checkerCommands.py',
 'leo/commands/controlCommands.py': '../commands/controlCommands.py',
 'leo/commands/convertCommands.py': '../commands/convertCommands.py',
 'leo/commands/debugCommands.py': '../commands/debugCommands.py',
 'leo/commands/editCommands.py': '../commands/editCommands.py',
 'leo/commands/editFileCommands.py': '../commands/editFileCommands.py',
 'leo/commands/gotoCommands.py': '../commands/gotoCommands.py',
 'leo/commands/helpCommands.py': '../commands/helpCommands.py',
 'leo/commands/keyCommands.py': '../commands/keyCommands.py',
 'leo/commands/killBufferCommands.py': '../commands/killBufferCommands.py',
 'leo/commands/rectangleCommands.py': '../commands/rectangleCommands.py',
 'leo/commands/searchCommands.py': '../commands/searchCommands.py',
 'leo/commands/spellCommands.py': '../commands/spellCommands.py',
 'leo/core/format-code.py': 'format-code.py',
 'leo/core/leoApp.py': 'leoApp.py',
 'leo/core/leoAst.py': 'leoAst.py',
 'leo/core/leoAtFile.py': 'leoAtFile.py',
 'leo/core/leoBackground.py': 'leoBackground.py',
 'leo/core/leoBeautify.py': 'leoBeautify.py',
 'leo/core/leoBridge.py': 'leoBridge.py',
 'leo/core/leoBridgeTest.py': 'leoBridgeTest.py',
 'leo/core/leoCache.py': 'leoCache.py',
 'leo/core/leoChapters.py': 'leoChapters.py',
 'leo/core/leoCheck.py': 'leoCheck.py',
 'leo/core/leoColor.py': 'leoColor.py',
 'leo/core/leoColorizer.py': 'leoColorizer.py',
 'leo/core/leoCommands.py': 'leoCommands.py',
 'leo/core/leoCompare.py': 'leoCompare.py',
 'leo/core/leoConfig.py': 'leoConfig.py',
 'leo/core/leoDebugger.py': 'leoDebugger.py',
 'leo/core/leoDynamicTest.py': 'leoDynamicTest.py',
 'leo/core/leoExternalFiles.py': 'leoExternalFiles.py',
 'leo/core/leoFileCommands.py': 'leoFileCommands.py',
 'leo/core/leoFind.py': 'leoFind.py',
 'leo/core/leoFrame.py': 'leoFrame.py',
 'leo/core/leoGlobals.py': 'leoGlobals.py',
 'leo/core/leoGui.py': 'leoGui.py',
 'leo/core/leoHistory.py': 'leoHistory.py',
 'leo/core/leoIPython.py': 'leoIPython.py',
 'leo/core/leoImport.py': 'leoImport.py',
 'leo/core/leoKeys.py': 'leoKeys.py',
 'leo/core/leoMenu.py': 'leoMenu.py',
 'leo/core/leoNodes.py': 'leoNodes.py',
 'leo/core/leoPersistence.py': 'leoPersistence.py',
 'leo/core/leoPlugins.py': 'leoPlugins.py',
 'leo/core/leoPrinting.py': 'leoPrinting.py',
 'leo/core/leoPymacs.py': 'leoPymacs.py',
 'leo/core/leoQt.py': 'leoQt.py',
 'leo/core/leoRope.py': 'leoRope.py',
 'leo/core/leoRst.py': 'leoRst.py',
 'leo/core/leoSessions.py': 'leoSessions.py',
 'leo/core/leoShadow.py': 'leoShadow.py',
 'leo/core/leoTangle.py': 'leoTangle.py',
 'leo/core/leoTest.py': 'leoTest.py',
 'leo/core/leoUndo.py': 'leoUndo.py',
 'leo/core/leoVersion.py': 'leoVersion.py',
 'leo/core/leoVim.py': 'leoVim.py',
 'leo/core/runLeo.py': 'runLeo.py',
 'leo/dist/setup.py': '../../setup.py',
 'leo/doc/FAQ.txt': 'FAQ.txt',
 'leo/doc/IpythonBridge.txt': 'IpythonBridge.txt',
 'leo/doc/appendices.txt': 'appendices.txt',
 'leo/doc/atShadow.txt': 'atShadow.txt',
 'leo/doc/cheatsheet.txt': 'cheatsheet.txt',
 'leo/doc/coloring.txt': 'coloring.txt',
 'leo/doc/commands.txt': 'commands.txt',
 'leo/doc/customizing.txt': 'customizing.txt',
 'leo/doc/debuggers.txt': 'debuggers.txt',
 'leo/doc/design.txt': 'design.txt',
 'leo/doc/download.txt': 'download.txt',
 'leo/doc/emacs.txt': 'emacs.txt',
 'leo/doc/frontMatter.txt': 'frontMatter.txt',
 'leo/doc/glossary.txt': 'glossary.txt',
 'leo/doc/html/index.html': 'html/index.html--&gt;',
 'leo/doc/installing.txt': 'installing.txt',
 'leo/doc/intermediatetopics.txt': 'intermediatetopics.txt',
 'leo/doc/intro.txt': 'intro.txt',
 'leo/doc/leoAttic.txt': '../doc/leoAttic.txt',
 'leo/doc/leoBridge.txt': 'leoBridge.txt',
 'leo/doc/leoNotes.txt': '../doc/leoNotes.txt',
 'leo/doc/leoProjects.txt': '../doc/leoProjects.txt',
 'leo/doc/leoToDo.txt': '../doc/leoToDo.txt',
 'leo/doc/leoToDoLater.txt': '../doc/leoToDoLater.txt',
 'leo/doc/leoandotherprograms.txt': 'leoandotherprograms.txt',
 'leo/doc/nutshell.txt': 'nutshell.txt',
 'leo/doc/outline-commands.txt': 'outline-commands.txt',
 'leo/doc/outlines.txt': 'outlines.txt',
 'leo/doc/plugin_catalog.py': 'plugin_catalog.py',
 'leo/doc/plugins.txt': 'plugins.txt',
 'leo/doc/preface.txt': 'preface.txt',
 'leo/doc/preliminaries.txt': 'preliminaries.txt',
 'leo/doc/release_notes.txt': 'release_notes.txt',
 'leo/doc/rstplugin3.txt': 'rstplugin3.txt',
 'leo/doc/running.txt': 'running.txt',
 'leo/doc/screen-shots.txt': 'screen-shots.txt',
 'leo/doc/slides.txt': 'slides.txt',
 'leo/doc/slideshows.txt': 'slideshows.txt',
 'leo/doc/sphinx-docs/Makefile': 'Makefile',
 'leo/doc/sphinx-docs/conf.py': 'conf.py',
 'leo/doc/sphinx-docs/index.rst': 'index.rst',
 'leo/doc/sphinx-docs/leo.core.rst': 'leo.core.rst',
 'leo/doc/sphinx-docs/leo.extensions.rst': 'leo.extensions.rst',
 'leo/doc/sphinx-docs/leo.external.concurrent.futures.rst': 'leo.external.concurrent.futures.rst',
 'leo/doc/sphinx-docs/leo.external.concurrent.rst': 'leo.external.concurrent.rst',
 'leo/doc/sphinx-docs/leo.external.rst': 'leo.external.rst',
 'leo/doc/sphinx-docs/leo.plugins.pygeotag.rst': 'leo.plugins.pygeotag.rst',
 'leo/doc/sphinx-docs/leo.plugins.rst': 'leo.plugins.rst',
 'leo/doc/sphinx-docs/leo.rst': 'leo.rst',
 'leo/doc/sphinx-docs/make.bat': 'make.bat',
 'leo/doc/sphinx-docs/requirements.txt': 'requirements.txt',
 'leo/doc/testimonials.txt': 'testimonials.txt',
 'leo/doc/tutorial.txt': 'tutorial.txt',
 'leo/doc/unitTesting.txt': 'unitTesting.txt',
 'leo/doc/usersguide.txt': 'usersguide.txt',
 'leo/doc/vimBindings.txt': 'vimBindings.txt',
 'leo/doc/whatsnew.txt': 'whatsnew.txt',
 'leo/doc/writingPlugins.txt': 'writingPlugins.txt',
 'leo/doc/zodb.txt': 'zodb.txt',
 'leo/external/codewise.py': '../external/codewise.py',
 'leo/external/edb.py': '../external/edb.py',
 'leo/external/leoSAGlobals.py': '../external/leoSAGlobals.py',
 'leo/external/leosax.py': '../external/leosax.py',
 'leo/external/log_broadcast.py': '../external/log_broadcast.py',
 'leo/external/log_listener.py': '../external/log_listener.py',
 'leo/external/lproto.py': '../external/lproto.py',
 'leo/external/make_stub_files.py': '../external/make_stub_files.py',
 'leo/external/npyscreen/__init__.py': '../external/npyscreen/__init__.py',
 'leo/external/npyscreen/apNPSApplication.py': '../external/npyscreen/apNPSApplication.py',
 'leo/external/npyscreen/apNPSApplicationAdvanced.py': '../external/npyscreen/apNPSApplicationAdvanced.py',
 'leo/external/npyscreen/apNPSApplicationEvents.py': '../external/npyscreen/apNPSApplicationEvents.py',
 'leo/external/npyscreen/apNPSApplicationManaged.py': '../external/npyscreen/apNPSApplicationManaged.py',
 'leo/external/npyscreen/apOptions.py': '../external/npyscreen/apOptions.py',
 'leo/external/npyscreen/eveventhandler.py': '../external/npyscreen/eveventhandler.py',
 'leo/external/npyscreen/fmActionForm.py': '../external/npyscreen/fmActionForm.py',
 'leo/external/npyscreen/fmActionFormV2.py': '../external/npyscreen/fmActionFormV2.py',
 'leo/external/npyscreen/fmFileSelector.py': '../external/npyscreen/fmFileSelector.py',
 'leo/external/npyscreen/fmForm.py': '../external/npyscreen/fmForm.py',
 'leo/external/npyscreen/fmFormMultiPage.py': '../external/npyscreen/fmFormMultiPage.py',
 'leo/external/npyscreen/fmFormMutt.py': '../external/npyscreen/fmFormMutt.py',
 'leo/external/npyscreen/fmFormMuttActive.py': '../external/npyscreen/fmFormMuttActive.py',
 'leo/external/npyscreen/fmFormWithMenus.py': '../external/npyscreen/fmFormWithMenus.py',
 'leo/external/npyscreen/fmPopup.py': '../external/npyscreen/fmPopup.py',
 'leo/external/npyscreen/fm_form_edit_loop.py': '../external/npyscreen/fm_form_edit_loop.py',
 'leo/external/npyscreen/globals.py': '../external/npyscreen/globals.py',
 'leo/external/npyscreen/muMenu.py': '../external/npyscreen/muMenu.py',
 'leo/external/npyscreen/muNewMenu.py': '../external/npyscreen/muNewMenu.py',
 'leo/external/npyscreen/npysGlobalOptions.py': '../external/npyscreen/npysGlobalOptions.py',
 'leo/external/npyscreen/npysNPSFilteredData.py': '../external/npyscreen/npysNPSFilteredData.py',
 'leo/external/npyscreen/npysThemeManagers.py': '../external/npyscreen/npysThemeManagers.py',
 'leo/external/npyscreen/npysThemes.py': '../external/npyscreen/npysThemes.py',
 'leo/external/npyscreen/npysTree.py': '../external/npyscreen/npysTree.py',
 'leo/external/npyscreen/npyspmfuncs.py': '../external/npyscreen/npyspmfuncs.py',
 'leo/external/npyscreen/npyssafewrapper.py': '../external/npyscreen/npyssafewrapper.py',
 'leo/external/npyscreen/proto_fm_screen_area.py': '../external/npyscreen/proto_fm_screen_area.py',
 'leo/external/npyscreen/stdfmemail.py': '../external/npyscreen/stdfmemail.py',
 'leo/external/npyscreen/utilNotify.py': '../external/npyscreen/utilNotify.py',
 'leo/external/npyscreen/util_viewhelp.py': '../external/npyscreen/util_viewhelp.py',
 'leo/external/npyscreen/wgFormControlCheckbox.py': '../external/npyscreen/wgFormControlCheckbox.py',
 'leo/external/npyscreen/wgNMenuDisplay.py': '../external/npyscreen/wgNMenuDisplay.py',
 'leo/external/npyscreen/wgannotatetextbox.py': '../external/npyscreen/wgannotatetextbox.py',
 'leo/external/npyscreen/wgautocomplete.py': '../external/npyscreen/wgautocomplete.py',
 'leo/external/npyscreen/wgboxwidget.py': '../external/npyscreen/wgboxwidget.py',
 'leo/external/npyscreen/wgbutton.py': '../external/npyscreen/wgbutton.py',
 'leo/external/npyscreen/wgcheckbox.py': '../external/npyscreen/wgcheckbox.py',
 'leo/external/npyscreen/wgcombobox.py': '../external/npyscreen/wgcombobox.py',
 'leo/external/npyscreen/wgdatecombo.py': '../external/npyscreen/wgdatecombo.py',
 'leo/external/npyscreen/wgeditmultiline.py': '../external/npyscreen/wgeditmultiline.py',
 'leo/external/npyscreen/wgfilenamecombo.py': '../external/npyscreen/wgfilenamecombo.py',
 'leo/external/npyscreen/wggrid.py': '../external/npyscreen/wggrid.py',
 'leo/external/npyscreen/wggridcoltitles.py': '../external/npyscreen/wggridcoltitles.py',
 'leo/external/npyscreen/wgmonthbox.py': '../external/npyscreen/wgmonthbox.py',
 'leo/external/npyscreen/wgmultiline.py': '../external/npyscreen/wgmultiline.py',
 'leo/external/npyscreen/wgmultilineeditable.py': '../external/npyscreen/wgmultilineeditable.py',
 'leo/external/npyscreen/wgmultilinetree.py': '../external/npyscreen/wgmultilinetree.py',
 'leo/external/npyscreen/wgmultilinetreeselectable.py': '../external/npyscreen/wgmultilinetreeselectable.py',
 'leo/external/npyscreen/wgmultiselect.py': '../external/npyscreen/wgmultiselect.py',
 'leo/external/npyscreen/wgmultiselecttree.py': '../external/npyscreen/wgmultiselecttree.py',
 'leo/external/npyscreen/wgpassword.py': '../external/npyscreen/wgpassword.py',
 'leo/external/npyscreen/wgselectone.py': '../external/npyscreen/wgselectone.py',
 'leo/external/npyscreen/wgslider.py': '../external/npyscreen/wgslider.py',
 'leo/external/npyscreen/wgtextbox.py': '../external/npyscreen/wgtextbox.py',
 'leo/external/npyscreen/wgtextbox_controlchrs.py': '../external/npyscreen/wgtextbox_controlchrs.py',
 'leo/external/npyscreen/wgtextboxunicode.py': '../external/npyscreen/wgtextboxunicode.py',
 'leo/external/npyscreen/wgtexttokens.py': '../external/npyscreen/wgtexttokens.py',
 'leo/external/npyscreen/wgtitlefield.py': '../external/npyscreen/wgtitlefield.py',
 'leo/external/npyscreen/wgwidget.py': '../external/npyscreen/wgwidget.py',
 'leo/external/npyscreen/wgwidget_proto.py': '../external/npyscreen/wgwidget_proto.py',
 'leo/external/obsolete/ipy_leo.py': '../external/obsolete/ipy_leo.py',
 'leo/external/py2cs.py': '../external/py2cs.py',
 'leo/external/sax2db.py': '../external/sax2db.py',
 'leo/plugins/FileActions.py': 'FileActions.py',
 'leo/plugins/active_path.py': 'active_path.py',
 'leo/plugins/add_directives.py': 'add_directives.py',
 'leo/plugins/at_folder.py': 'at_folder.py',
 'leo/plugins/at_produce.py': 'at_produce.py',
 'leo/plugins/at_view.py': 'at_view.py',
 'leo/plugins/attrib_edit.py': 'attrib_edit.py',
 'leo/plugins/auto_colorize2_0.py': 'auto_colorize2_0.py',
 'leo/plugins/backlink.py': 'backlink.py',
 'leo/plugins/baseNativeTree.py': '../plugins/baseNativeTree.py',
 'leo/plugins/bibtex.py': 'bibtex.py',
 'leo/plugins/bigdash.py': 'bigdash.py',
 'leo/plugins/bookmarks.py': 'bookmarks.py',
 'leo/plugins/bzr_qcommands.py': 'bzr_qcommands.py',
 'leo/plugins/chapter_hoist.py': 'chapter_hoist.py',
 'leo/plugins/codewisecompleter.py': 'codewisecompleter.py',
 'leo/plugins/colorize_headlines.py': 'colorize_headlines.py',
 'leo/plugins/contextmenu.py': 'contextmenu.py',
 'leo/plugins/ctagscompleter.py': 'ctagscompleter.py',
 'leo/plugins/cursesGui.py': 'cursesGui.py',
 'leo/plugins/cursesGui2.py': 'cursesGui2.py',
 'leo/plugins/datenodes.py': 'datenodes.py',
 'leo/plugins/debugger_pudb.py': 'debugger_pudb.py',
 'leo/plugins/demo.py': 'demo.py',
 'leo/plugins/dragdropgoodies.py': 'dragdropgoodies.py',
 'leo/plugins/dtest.py': 'dtest.py',
 'leo/plugins/dump_globals.py': 'dump_globals.py',
 'leo/plugins/empty_leo_file.py': 'empty_leo_file.py',
 'leo/plugins/enable_gc.py': 'enable_gc.py',
 'leo/plugins/examples/chinese_menu.py': 'examples/chinese_menu.py',
 'leo/plugins/examples/french_fm.py': 'examples/french_fm.py',
 'leo/plugins/examples/override_classes.py': 'examples/override_classes.py',
 'leo/plugins/examples/override_commands.py': 'examples/override_commands.py',
 'leo/plugins/examples/print_cp.py': 'examples/print_cp.py',
 'leo/plugins/examples/redefine_put.py': 'examples/redefine_put.py',
 'leo/plugins/expfolder.py': 'expfolder.py',
 'leo/plugins/free_layout.py': '../plugins/free_layout.py',
 'leo/plugins/ftp.py': 'ftp.py',
 'leo/plugins/geotag.py': 'geotag.py',
 'leo/plugins/gitarchive.py': 'gitarchive.py',
 'leo/plugins/graphcanvas.py': 'graphcanvas.py',
 'leo/plugins/import_cisco_config.py': 'import_cisco_config.py',
 'leo/plugins/importers/__init__.py': 'importers/__init__.py',
 'leo/plugins/importers/c.py': 'importers/c.py',
 'leo/plugins/importers/coffeescript.py': 'importers/coffeescript.py',
 'leo/plugins/importers/csharp.py': 'importers/csharp.py',
 'leo/plugins/importers/ctext.py': 'importers/ctext.py',
 'leo/plugins/importers/dart.py': 'importers/dart.py',
 'leo/plugins/importers/elisp.py': 'importers/elisp.py',
 'leo/plugins/importers/html.py': 'importers/html.py',
 'leo/plugins/importers/ini.py': 'importers/ini.py',
 'leo/plugins/importers/ipynb.py': 'importers/ipynb.py',
 'leo/plugins/importers/java.py': 'importers/java.py',
 'leo/plugins/importers/javascript.py': 'importers/javascript.py',
 'leo/plugins/importers/json.py': 'importers/json.py',
 'leo/plugins/importers/leo_rst.py': 'importers/leo_rst.py',
 'leo/plugins/importers/linescanner.py': 'importers/linescanner.py',
 'leo/plugins/importers/lua.py': 'importers/lua.py',
 'leo/plugins/importers/markdown.py': 'importers/markdown.py',
 'leo/plugins/importers/org.py': 'importers/org.py',
 'leo/plugins/importers/otl.py': 'importers/otl.py',
 'leo/plugins/importers/pascal.py': 'importers/pascal.py',
 'leo/plugins/importers/perl.py': 'importers/perl.py',
 'leo/plugins/importers/php.py': 'importers/php.py',
 'leo/plugins/importers/python.py': 'importers/python.py',
 'leo/plugins/importers/tcl.py': 'importers/tcl.py',
 'leo/plugins/importers/typescript.py': 'importers/typescript.py',
 'leo/plugins/importers/xml.py': 'importers/xml.py',
 'leo/plugins/initinclass.py': 'initinclass.py',
 'leo/plugins/interact.py': 'interact.py',
 'leo/plugins/jinjarender.py': 'jinjarender.py',
 'leo/plugins/leoOPML.py': 'leoOPML.py',
 'leo/plugins/leoPluginNotes.txt': 'leoPluginNotes.txt',
 'leo/plugins/leo_interface.py': 'leo_interface.py',
 'leo/plugins/leo_pdf.py': 'leo_pdf.py',
 'leo/plugins/leo_to_html.py': 'leo_to_html.py',
 'leo/plugins/leo_to_rtf.py': 'leo_to_rtf.py',
 'leo/plugins/leocursor.py': 'leocursor.py',
 'leo/plugins/leofeeds.py': 'leofeeds.py',
 'leo/plugins/leomail.py': 'leomail.py',
 'leo/plugins/leomylyn.py': 'leomylyn.py',
 'leo/plugins/leoremote.py': 'leoremote.py',
 'leo/plugins/leoscreen.py': 'leoscreen.py',
 'leo/plugins/lineNumbers.py': 'lineNumbers.py',
 'leo/plugins/livecode.py': 'livecode.py',
 'leo/plugins/macros.py': 'macros.py',
 'leo/plugins/markup_inline.py': 'markup_inline.py',
 'leo/plugins/maximizeNewWindows.py': 'maximizeNewWindows.py',
 'leo/plugins/mime.py': 'mime.py',
 'leo/plugins/mnplugins.py': 'mnplugins.py',
 'leo/plugins/mod_autosave.py': 'mod_autosave.py',
 'leo/plugins/mod_framesize.py': 'mod_framesize.py',
 'leo/plugins/mod_http.py': 'mod_http.py',
 'leo/plugins/mod_leo2ascd.py': 'mod_leo2ascd.py',
 'leo/plugins/mod_leo2ascd.txt': 'mod_leo2ascd.txt',
 'leo/plugins/mod_read_dir_outline.py': 'mod_read_dir_outline.py',
 'leo/plugins/mod_scripting.py': 'mod_scripting.py',
 'leo/plugins/mod_speedups.py': 'mod_speedups.py',
 'leo/plugins/mod_timestamp.py': 'mod_timestamp.py',
 'leo/plugins/multifile.py': 'multifile.py',
 'leo/plugins/nav_qt.py': 'nav_qt.py',
 'leo/plugins/nested_splitter.py': '../plugins/nested_splitter.py',
 'leo/plugins/niceNosent.py': 'niceNosent.py',
 'leo/plugins/nodeActions.py': 'nodeActions.py',
 'leo/plugins/nodediff.py': 'nodediff.py',
 'leo/plugins/nodetags.py': 'nodetags.py',
 'leo/plugins/nodewatch.py': 'nodewatch.py',
 'leo/plugins/notebook.py': 'notebook.py',
 'leo/plugins/obsolete/ironPythonGui.py': './obsolete/ironPythonGui.py',
 'leo/plugins/obsolete/swing_gui.py': './obsolete/swing_gui.py',
 'leo/plugins/obsolete/tkGui.py': './obsolete/tkGui.py',
 'leo/plugins/obsolete/wxGui.py': './obsolete/wxGui.py',
 'leo/plugins/open_shell.py': 'open_shell.py',
 'leo/plugins/outline_export.py': 'outline_export.py',
 'leo/plugins/paste_as_headlines.py': 'paste_as_headlines.py',
 'leo/plugins/plugins_menu.py': 'plugins_menu.py',
 'leo/plugins/pretty_print.py': 'pretty_print.py',
 'leo/plugins/projectwizard.py': 'projectwizard.py',
 'leo/plugins/pyplot_backend.py': 'pyplot_backend.py',
 'leo/plugins/python_terminal.py': 'python_terminal.py',
 'leo/plugins/qtGui.py': '../plugins/qtGui.py',
 'leo/plugins/qtNotes.txt': 'qtNotes.txt',
 'leo/plugins/qt_commands.py': '../plugins/qt_commands.py',
 'leo/plugins/qt_events.py': '../plugins/qt_events.py',
 'leo/plugins/qt_frame.py': '../plugins/qt_frame.py',
 'leo/plugins/qt_gui.py': '../plugins/qt_gui.py',
 'leo/plugins/qt_idle_time.py': '../plugins/qt_idle_time.py',
 'leo/plugins/qt_quickheadlines.py': '../plugins/qt_quickheadlines.py',
 'leo/plugins/qt_text.py': '../plugins/qt_text.py',
 'leo/plugins/qt_tree.py': '../plugins/qt_tree.py',
 'leo/plugins/quickMove.py': 'quickMove.py',
 'leo/plugins/quicksearch.py': 'quicksearch.py',
 'leo/plugins/quit_leo.py': 'quit_leo.py',
 'leo/plugins/read_only_nodes.py': 'read_only_nodes.py',
 'leo/plugins/redirect_to_log.py': 'redirect_to_log.py',
 'leo/plugins/richtext.py': 'richtext.py',
 'leo/plugins/rss.py': 'rss.py',
 'leo/plugins/rst3.py': 'rst3.py',
 'leo/plugins/run_nodes.py': 'run_nodes.py',
 'leo/plugins/screen_capture.py': 'screen_capture.py',
 'leo/plugins/screencast.py': 'screencast.py',
 'leo/plugins/screenshots.py': 'screenshots.py',
 'leo/plugins/script_io_to_body.py': 'script_io_to_body.py',
 'leo/plugins/scripts_menu.py': 'scripts_menu.py',
 'leo/plugins/setHomeDirectory.py': 'setHomeDirectory.py',
 'leo/plugins/settings_finder.py': 'settings_finder.py',
 'leo/plugins/sftp.py': 'sftp.py',
 'leo/plugins/slideshow.py': 'slideshow.py',
 'leo/plugins/spydershell.py': 'spydershell.py',
 'leo/plugins/startfile.py': 'startfile.py',
 'leo/plugins/stickynotes.py': 'stickynotes.py',
 'leo/plugins/stickynotes_plus.py': 'stickynotes_plus.py',
 'leo/plugins/systray.py': 'systray.py',
 'leo/plugins/tables.py': 'tables.py',
 'leo/plugins/template_gui.py': 'template_gui.py',
 'leo/plugins/test/ekr_test.py': 'test/ekr_test.py',
 'leo/plugins/test/failed_import.py': 'test/failed_import.py',
 'leo/plugins/test/failed_to_load_plugin.py': 'test/failed_to_load_plugin.py',
 'leo/plugins/test/syntax_error_plugin.py': 'test/syntax_error_plugin.py',
 'leo/plugins/testRegisterCommand.py': 'testRegisterCommand.py',
 'leo/plugins/textnode.py': 'textnode.py',
 'leo/plugins/threadutil.py': 'threadutil.py',
 'leo/plugins/timestamp.py': 'timestamp.py',
 'leo/plugins/todo.py': 'todo.py',
 'leo/plugins/tomboy_import.py': 'tomboy_import.py',
 'leo/plugins/trace_gc_plugin.py': 'trace_gc_plugin.py',
 'leo/plugins/trace_keys.py': 'trace_keys.py',
 'leo/plugins/trace_tags.py': 'trace_tags.py',
 'leo/plugins/valuespace.py': 'valuespace.py',
 'leo/plugins/viewrendered.py': 'viewrendered.py',
 'leo/plugins/viewrendered2.py': 'viewrendered2.py',
 'leo/plugins/vim.py': 'vim.py',
 'leo/plugins/vnodes-history.py': 'vnodes-history.py',
 'leo/plugins/wikiview.py': 'wikiview.py',
 'leo/plugins/word_count.py': 'word_count.py',
 'leo/plugins/word_export.py': 'word_export.py',
 'leo/plugins/writers/__init__.py': 'writers/__init__.py',
 'leo/plugins/writers/basewriter.py': 'writers/basewriter.py',
 'leo/plugins/writers/ctext.py': 'writers/ctext.py',
 'leo/plugins/writers/dart.py': 'writers/dart.py',
 'leo/plugins/writers/ipynb.py': 'writers/ipynb.py',
 'leo/plugins/writers/json.py': 'writers/json.py',
 'leo/plugins/writers/leo_rst.py': 'writers/leo_rst.py',
 'leo/plugins/writers/markdown.py': 'writers/markdown.py',
 'leo/plugins/writers/org.py': 'writers/org.py',
 'leo/plugins/writers/otl.py': 'writers/otl.py',
 'leo/plugins/writers/test.py': 'writers/test.py',
 'leo/plugins/xemacs.py': 'xemacs.py',
 'leo/plugins/xml_edit.py': 'xml_edit.py',
 'leo/plugins/xsltWithNodes.py': 'xsltWithNodes.py',
 'leo/plugins/zenity_file_dialogs.py': 'zenity_file_dialogs.py',
 'leo/scripts/build-leo.bat': 'build-leo.bat',
 'leo/scripts/elevate.py': 'elevate.py',
 'leo/scripts/gen_blender_docs.py': 'gen_blender_docs.py',
 'leo/scripts/leoScripts.txt': 'leoScripts.txt',
 'leo/scripts/register-leo.leox': 'register-leo.leox',
 'leo/scripts/unregister-leo.leox': 'unregister-leo.leox',
 'leo/test/activeUnitTests.txt': 'activeUnitTests.txt',
 'leo/test/inactiveTests.txt': 'inactiveTests.txt',
 'leo/test/unitTestStartup.txt': 'unitTestStartup.txt',
 'leo/test/unittest/at-file-line-number-test.c': 'unittest/at-file-line-number-test.c',
 'leo/test/unittest/at-file-line-number-test.py': 'unittest/at-file-line-number-test.py',
 'leo/test/unittest/at-path-test1.py': '../test/unittest/at-path-test1.py',
 'leo/test/unittest/at-path-test2.py': 'at-path-test2.py',
 'leo/test/unittest/at-path-test3.py': 'at-path-test3.py',
 'leo/test/unittest/at-thin-html-test.html': 'unittest/at-thin-html-test.html--&gt;',
 'leo/test/unittest/at-thin-line-number-test.py': 'unittest/at-thin-line-number-test.py',
 'leo/test/unittest/at-thin-test.py': 'unittest/at-thin-test.py',
 'leo/test/unittest/batchTest.py': 'unittest/batchTest.py',
 'leo/test/unittest/errorTest.py': 'unittest/errorTest.py',
 'leo/test/unittest/tex-error.tex': 'unittest/tex-error.tex'}</t>
<t tx="vitalije.20170720214432.6">_files_cache = {}
def get_file(n):
    fname = derived_files[n] if type(n) is int else n
    s = _files_cache.get(fname)
    if s:
        return s
    s = g.readFileIntoUnicodeString(fname)
    s = s.replace('\r','')
    _files_cache[fname] = s
    return s</t>
<t tx="vitalije.20170720214432.7">def get_lines(n):
    return g.splitLines(get_file(n))</t>
<t tx="vitalije.20170720214432.8">def headline_for_ideal_import(j):
    flines = enumerate(get_lines(j))
    ver, kind, delim_st, delim_en = read_header(flines)
    g.trace('kind', kind, 'delim_st', delim_st)
    ptrns = get_patterns(delim_st)
    pat = ptrns.node_start
    for i, line in flines:
        m = at_node_start(i, line, pat)
        if not m: continue
        break
    else:
        return
    hfi = m[-1].strip()
    if hfi.endswith('--&gt;'):
        hfi = hfi[:-3].strip()
    return hfi</t>
<t tx="vitalije.20170720214432.9">def ideal_path_for_import(j):
    fn = derived_files[j]
    if fn.find('leo/doc/sphinx-docs') &gt; -1:
        return '%s/doc/sphinx-docs'%g.app.leoDir
    elif fn.find('leo/doc/') &gt; -1:
        return '%s/doc'%g.app.leoDir
    elif fn.find('leo/scripts/') &gt; -1:
        return '%s/scripts'%g.app.leoDir
    elif fn.find('leo/plugins/') &gt; -1:
        return '%s/plugins'%g.app.leoDir
    elif j == 392:
        return '%s/dist/junk/junk'%g.app.leoDir
    elif j in (400, 401):
        return '%s/test/unittest'%g.app.leoDir
    elif fn.find('leo/test/') &gt; -1:
        return '%s/test'%g.app.leoDir
    else:
        return '%s/core'%g.app.leoDir</t>
<t tx="vitalije.20170720214543.2">At first this file contained only scripts in `exp-3 dev` node.
&lt;&lt;about exp-3 dev&gt;&gt; original about this file

&lt;&lt;about exp-4 dev&gt;&gt;

&lt;&lt;about exp-5 dev&gt;&gt;

&lt;&lt;about exp-6 dev&gt;&gt;

&lt;&lt;about exp-7 dev&gt;&gt;

About exp-8 dev

24-07-2017 23:02:56

Finally, load_derived_file(lines) function is implemented, and it successfully reads
all derived files from Leo installation directory.

functions **p_to_lines** in exp-7 and **load_derived_file** in exp-8, both are
standalone and self-contained, without any external dependences (except of course
g and leoNodes).

Profiling showed that this style of code organization gives better (more performant) results,
than class oriented code organization.

Profiling load_derived_file against at.read on my machine (using leo/test/activeUnitTest.txt)
gives following data:

at.read(fromString) 406.6ms on average
load_derived_file   119.7ms on average
</t>
<t tx="vitalije.20170720214636.1">@path /media/vitalije/home11/vitalije/programi/leo-editor/trunk-sqlite/leo/test</t>
<t tx="vitalije.20170721074235.1">This file contains scripts that test how fast can be calculated
line number in external file for any given line in at-anyfile
subtree.

To run test code in `exp-3 dev @key=Alt-4` should be executed.

It first imports leo/core/leoApp.py derived file under the
EXTERNALS node as the first child.

Then it patches leo.core.VNode class adding .lines get-property
which aims to reduce the number of using g.splitLines.

Then it profiles function f_line_numerate which visits the 
subtree of at-file node and to each vnode in subtree it attaches
f_lines tuple which contains ordering numbers of lines in that
node. This property can be displayed in gutter for example.

Profiling on my machine shows that it is able to renumerate
whole subtree 100 times in less than 1.8 secodns which gives
on average 18ms per renumeration.

Note: this is just an experiment and code is not thoroughly
tested neither it is proved to be correct for all possible
Leo directives. However, it most probably can be fixed if
any error in line numbering is noticed.</t>
<t tx="vitalije.20170721074430.1">import itertools
import re
import leo.core.leoNodes as leoNodes
import difflib
import timeit
import pprint
@others
c.frame.log.selectTab('Log')
c.frame.log.clearLog()
compare_reading_all_files()

g.es(len(tuple(valid_files())) - 1, 'files successfully read')

clear_gnxDict()
c.redraw()</t>
<t tx="vitalije.20170721075007.1">def run_experiment(func, n, keep_node=False):
    p = c.find_h('EXTERNALS')[0]
    ok = False
    try:
        do_import_file(n)
        c.redraw()
        ok = func(n, p.lastChild())
        if ok:
            g.es('ok')
        else:
            g.es('experiment', func.__name__, 'failed')
    except Exception as e:
        g.es_exception(e)
        g.traceback.print_exc()
    finally:
        if not keep_node:
            p.lastChild().doDelete()
            clear_gnxDict()
    return ok</t>
<t tx="vitalije.20170721075016.1"></t>
<t tx="vitalije.20170721075355.1">def valid_files():
    for j,n in enumerate(derived_files):
        if j not in false_positives:
            yield j, n</t>
<t tx="vitalije.20170721083818.1">leo_header_pat = re.compile('^(.+?)@[+]leo-ver=(\\d+)-(thin|file)(.*?)\n$')
def read_header(flines):
    for i, line in flines:
        m = leo_header_pat.match(line)
        if m:
            return (m.group(2), # version
                    m.group(3), # kind
                    m.group(1), # delim_start
                    m.group(4), # delim_end
                )</t>
<t tx="vitalije.20170721090011.1">def at_sect_ref(i, line, pat):
    m = pat.match(line)
    if m:
        return (i, # line no
                m.group(1), #indent
                m.group(3), #section ref
                m.group(2) == '+', #is_start
                m.group(4)) #after sect ref
    else:
        return False</t>
<t tx="vitalije.20170721090017.1">def sect_refs(data):
    flines, ptrns, verbatims = data
    pat = ptrns.section

    starts = []

    for i, line in flines:

        if i in verbatims: continue

        m = at_sect_ref(i, line, pat)
        if not m: continue

        j, indent, sref, is_start, after = m

        if is_start:
            starts.append(m)
        else:
            m_st = starts.pop()
            j, indent, sref, is_start, after = m_st
            yield (j, i, indent, sref, after)</t>
<t tx="vitalije.20170721090105.1">patterns = {
    '#': g.bunch(
            node_start = re.compile('^(\\s*)#@[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*)$', re.DOTALL),
            section = re.compile('^(\\s*)#@([+]|-)&lt;{2}(.+?)&gt;{2}(.*)$',
                            re.DOTALL),
            others = re.compile('^(\\s*)#@([+]|-)others\\s*$', re.DOTALL),
            all = re.compile('^(\\s*)#@([+]|-)all\\s*$', re.DOTALL),
        ),
    '.. ': g.bunch(
            node_start = re.compile('^(\\s*)[.][.] @[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*)$', re.DOTALL),
            section = re.compile('^(\\s*)[.][.] @([+]|-)&lt;{2}(.+?)&gt;{2}(.*)$',
                            re.DOTALL),
            others = re.compile('^(\\s*)[.][.] @([+]|-)others\\s*$', re.DOTALL),
            all = re.compile('^(\\s*)[.][.] @([+]|-)all\\s*$', re.DOTALL),
        ),
    '&lt;!--': g.bunch(
            node_start = re.compile('^(\\s*)&lt;!--@[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*?)--&gt;$', re.DOTALL),
            section = re.compile('^(\\s*)&lt;!--@([+]|-)&lt;{2}(.+?)&gt;{2}--&gt;(.*?)$',
                                    re.DOTALL),
            others = re.compile('^(\\s*)&lt;!--@([+]|-)others--&gt;\\s*$', re.DOTALL),
            all = re.compile('^(\\s*)&lt;!--@([+]|-)all--&gt;\\s*$', re.DOTALL),
        ),
    '/*': g.bunch(
            node_start = re.compile('^(\\s*)/[*]@[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*?)[*]/$', re.DOTALL),
            section = re.compile('^(\\s*)/[*]@([+]|-)&lt;{2}(.+?)&gt;{2}[*]/(.*?)$',
                                     re.DOTALL),
            others = re.compile('^(\\s*)/[*]@([+]|-)others[*]/\\s*$', re.DOTALL),
            all = re.compile('^(\\s*)/[*]@([+]|-)all[*]/\\s*$', re.DOTALL),
        ),
    '//': g.bunch(
            node_start = re.compile('^(\\s*)//@[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*)$', re.DOTALL),
            section = re.compile('^(\\s*)//@([+]|-)&lt;{2}(.+?)&gt;{2}(.*)$',
                                    re.DOTALL),
            others = re.compile('^(\\s*)//@([+]|-)others\\s*$', re.DOTALL),
            all = re.compile('^(\\s*)//@([+]|-)all\\s*$', re.DOTALL),
        ),
    ';': g.bunch(
            node_start = re.compile('^(\\s*);@[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*)$', re.DOTALL),
            section = re.compile('^(\\s*);@([+]|-)&lt;{2}(.+?)&gt;{2}(.*)$',
                                    re.DOTALL),
            others = re.compile('^(\\s*);@([+]|-)others\\s*$', re.DOTALL),
            all = re.compile('^(\\s*);@([+]|-)all\\s*$', re.DOTALL),
        ),
    'REM ': g.bunch(
            node_start = re.compile('^(\\s*)REM @[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*)$', re.DOTALL),
            section = re.compile('^(\\s*)REM @([+]|-)&lt;{2}(.+?)&gt;{2}(.*)$',
                                    re.DOTALL),
            others = re.compile('^(\\s*)REM @([+]|-)others\\s*$', re.DOTALL),
            all = re.compile('^(\\s*)REM @([+]|-)all\\s*$', re.DOTALL),
        ),
    '%': g.bunch(
            node_start = re.compile('^(\\s*)%@[+]node:([^:]+): '
                                    '[*](\\d+)?([*])? (.*)$', re.DOTALL),
            section = re.compile('^(\\s*)%@([+]|-)&lt;{2}(.+?)&gt;{2}(.*)$',
                                    re.DOTALL),
            others = re.compile('^(\\s*)%@([+]|-)others\\s*$', re.DOTALL),
            all = re.compile('^(\\s*)%@([+]|-)all\\s*$', re.DOTALL),
        ),
}</t>
<t tx="vitalije.20170721091325.1">def match_at_others(i, line, pat):
    m = pat.match(line)
    if m:
        return (i, m.group(1), m.group(2) == '+')
    else:
        return False</t>
<t tx="vitalije.20170721095723.1">def at_all_refs(data):
    flines, ptrns, verbatims = data
    pat = ptrns.all

    starts = []

    for i, line in flines:

        if i in verbatims: continue

        m = match_at_all(i, line, pat)

        if m and m[2]:
            starts.append(m)
        elif m:
            j, indent, junk = starts.pop()
            yield j, i, indent
</t>
<t tx="vitalije.20170721095723.3">def match_at_all(i, line, pat):
    m = pat.match(line)
    if m:
        return (i, m.group(1), m.group(2) == '+')
    else:
        return False</t>
<t tx="vitalije.20170721100518.1">def read_verbatims(flines, delim_st):
    st = delim_st + '@verbatim'
    in_verb = False
    for i, line in flines:
        if in_verb:
            yield i
            in_verb = False
        else:
            in_verb = line.startswith(st)</t>
<t tx="vitalije.20170721100524.1">def find_all(n, at_all_data):
    '''Returns at-all block starting on line n, or
       first following block. If such block can't
       be found, returns None.'''

    # Note: at-all blocks can't be nested nor they can overlap
    #       and at_all_data is in ascending order
    for i, j, ws in at_all_data:
        if i &lt; n: continue
        return i, j, ws

</t>
<t tx="vitalije.20170721131019.1">end_delimiters = {
    '&lt;!--': '-''-&gt;',
    '/*': '*''/'
}
def strip_end_delimiter(line, delim_st):
    delim_en = end_delimiters.get(delim_st)
    if delim_en:
        i = line.rfind(delim_en)
        if i &gt; -1:
            return line[:i] + line[i + len(delim_en):]
    return line</t>
<t tx="vitalije.20170721173437.1">def read_at_last_lines(analytics):
    a = analytics; flines = a.flines
    leo_end = a.delim_st + '@-leo'
    j, line = flines[-1]
    while j &gt; 0:
        if line.startswith(leo_end):
            # last lines comes after at-leo sentinel line
            break
        # going backword from the end of file
        j, line = flines[j - 1]

    # in j is index of at-leo sentinel line
    for i, line in flines[j+1:]:
        yield line</t>
<t tx="vitalije.20170721174314.1">def indent(n, s):
    return ' ' * n + s</t>
<t tx="vitalije.20170721180227.1">def end_of_node_in_all(st, end_all, analytics):
    a = analytics
    # inside at-all block: 
    #      node ends on first next node start
    #      or at the end of at-all block
    is_gt = lambda x: x &gt; st
    after_nodes = filter(is_gt, a.nstart.keys())
    return min(after_nodes, default=end_all)</t>
<t tx="vitalije.20170721180649.1">def end_of_node_in_others(st, lev, analytics):
    a = analytics
    # in others block node ends at the end of others block
    # or on the beginning of node at the same level or upper  
    j = len(a.flines)
    for gnx, nd in a.nodes.items():
        for (i, lev2, h2, wsp) in nd:
            if lev2 &lt;= lev and i &gt; st:
                j = min(j, i)
    return j</t>
<t tx="vitalije.20170721184930.1">def get_patterns(delim_st):
    ptrns = patterns.get(delim_st)
    if not ptrns:
        g.error('no valid patterns for delimiter: %r'%delim_st)
    return ptrns</t>
<t tx="vitalije.20170721190334.1"></t>
<t tx="vitalije.20170721192544.1">if i in verbatims:
    # verbatim line: yield it as it is
    yield flines[i][1]
    i += 1</t>
<t tx="vitalije.20170721192602.1">elif i + 1 in verbatims:
    yield flines[i][1]
    i += 1</t>
<t tx="vitalije.20170721192639.1">elif all_ij and i == all_ij[0]:
    # we are on the beginning of at-all block
    i = all_ij[1] + 1 # after at-all block
    yield all_ij[2][ind:] + '@all\n'
    # find next at-all block
    all_ij = find_all(i, a.atall)</t>
<t tx="vitalije.20170721192649.1">elif i in a.othrs:
    # we are on the beginning of at-others block
    en, wsp = a.othrs[i]
    i = en + 1 # after at-others block
    yield indent(wsp - ind, '@others\n')</t>
<t tx="vitalije.20170721192800.1">elif i in a.sects:
    # we are on the beginning of section block
    en, wsp, sref, after = a.sects[i]
    i = en + 1 # after section block
    # if there was delim_end, the newline was striped
    nl = '' if after.endswith('\n') else '\n'
    yield indent(wsp - ind, g.angleBrackets(sref) + after + nl)</t>
<t tx="vitalije.20170721192809.1">elif i in a.nstart:
    # we are at the beginning of node
    gnx2 = a.nstart[i]
    en = end_of_node(gnx2, analytics)
    i = en
    in_raw = False</t>
<t tx="vitalije.20170721192819.1">elif i in a.oend:
    in_raw = False
    break</t>
<t tx="vitalije.20170721192855.1">else:
    line = flines[i][1]
    if len(line) &lt; ind:
        # perhaps line was empty and we are at some indent
        # using line[ind:] would strip newline
        yield line
    else:
        yield line[ind:]
    i += 1</t>
<t tx="vitalije.20170721193719.1"></t>
<t tx="vitalije.20170721194006.1">head = read_header(flines)
if not head:
    g.warning('no valid header. is this really derived file?')
ver, kind, delim_st, delim_en = head</t>
<t tx="vitalije.20170721194026.1">verbatims = tuple(read_verbatims(flines, delim_st))</t>
<t tx="vitalije.20170721194127.1">data = flines, get_patterns(delim_st), verbatims</t>
<t tx="vitalije.20170721194142.1">at_all_data = tuple(at_all_refs(data))</t>
<t tx="vitalije.20170721194157.1">@ in at-all files there are multiple at+node sentinels
  with the same gnx for cloned nodes. So node_data must
  contain tuple of node data tuples for any gnx.
@c

node_data = {}
for i, ind, gnx, lev, h in node_start_lines(data):
    t = node_data.get(gnx, tuple()) # previous or new empty tuple
    nd = (i, lev, h, len(ind)) # tuple of node data (for one instance of node)
    node_data[gnx] = t + (nd,) #  add this data to tuple for this gnx

# node_starts: keys are indexes of starting line, values are gnxes
node_starts = dict((x[0], x[2]) for x in node_start_lines(data))</t>
<t tx="vitalije.20170721194206.1"># sect_refs yields tuples of the following form:
#
#      start, end, ident_str, reference name and after reference text
#       0   |  1   |   2     |          3     |           4          |
#
sdata_fun = lambda x:(x[1], len(x[2]), x[3], x[4])

# key is start, value is (end, len(ident), ref, afterref)
sect_data = dict((x[0], sdata_fun(x)) for x in sect_refs(data))</t>
<t tx="vitalije.20170721194213.1"># keys are index of start line, values are tuples of (end, len(indent))
at_oth_data = dict((st, (en, len(ind))) for st,en,ind in at_others_refs(data))

# ending line indexes for at-others sentinels
oth_ends = set(x[0] for x in at_oth_data.values())</t>
<t tx="vitalije.20170721201600.1">def compare_reading_file(n, p):
    analytics = analyze_lines(get_lines(n))
    for i, p1 in enumerate(p.self_and_subtree()):
        gnx = p1.gnx
        v = c.fileCommands.gnxDict[gnx]
        if i == 0:
            s = ''.join(body_lines_of_top_node(gnx, analytics))
        else:
            s = ''.join(body_lines_of_node(gnx, analytics))
        if v.b != s:
            g.es('\n',v.h)
            g.es(v.gnx)
            g.es(s)
            p1 = next((x for x in c.find_h(v.h) if x.v is v), None)
            c.redraw(p1)
            return False
        # if i % 35 == 34:
        #     g.es('.')
        # else:
        #     g.es('.', newline=False)
    return True</t>
<t tx="vitalije.20170721201605.1">def compare_reading_all_files():
    for i, fn in valid_files():
        # for faster testing only few files are tested
        # comment following line to test all files
        #if i not in (32, 160, 180, 395, 401):continue
        if not run_experiment(compare_reading_file, i, False):
            g.es('file number:', i)
            break</t>
<t tx="vitalije.20170721202706.1">elif in_raw:
    line = flines[i][1]
    if line.startswith(atraw_end):
        in_raw = False
    yield line
    i += 1</t>
<t tx="vitalije.20170721203441.1">elif flines[i][1][len(a.delim_st)+1:].startswith(atraw_end):
    in_raw = True
    yield line
    i += 1</t>
<t tx="vitalije.20170721204227.1">elif all_ij and all_ij[0] &lt; i &lt; all_ij[1]:
    # at-others and sections are not processed
    line = flines[i]
    i += 1
    yield line</t>
<t tx="vitalije.20170721210632.1">if in_verbatim:
    yield line
    in_verbatim = False
    continue</t>
<t tx="vitalije.20170721210647.1">if line.startswith(verbatim):
    in_verbatim = True
    continue</t>
<t tx="vitalije.20170721210702.1">atdoc, line = check_at_doc(line, delim_st)
if atdoc:
    yield line
    in_doc = True
    continue</t>
<t tx="vitalije.20170721210713.1">atcode, line = check_at_code(line, delim_st)
if atcode:
    yield line
    in_doc = False
    continue</t>
<t tx="vitalije.20170722122928.1"></t>
<t tx="vitalije.20170722123231.1">import itertools
import re
import leo.core.leoNodes as leoNodes
import difflib
import timeit
import pprint
@others
c.frame.log.selectTab('Log')
c.frame.log.clearLog()
#g.es(time_test(100, test_160_new), 'seconds iterator writer')
#g.es(time_test(100, test_160_old), 'seconds old writer')
def test_all_valid():
    i = 0
    res = set()
    for j, fn in valid_files():
        ok = '.' if test_compare_n(j, True) else 'E'
        if ok == 'E':
            res.add(j)
            if len(res) &gt; 5:break
        g.es(ok, newline=i % 35 == 34)
        i += 1
    g.es('')
    if res:
        g.es(res)
        return False
    return True
g.es('success' if test_all_valid() else 'failure')
#g.es('success' if test_compare_n(250) else 'failure')
</t>
<t tx="vitalije.20170722124118.1">def prepare():
    p = starting_pos()
    if not p:
        ok, p = do_import_file(160)
        if ok: return p
    assert p, 'Error'
    return p
def prepare395():
    p = c.find_h('@file activeUnitTests.txt')
    if not p:
        ok, p = do_import_file(395)
        c.redraw()
    else:
        p = p[0]
    assert p, 'Error'
    return p </t>
<t tx="vitalije.20170722133741.1">m = doc_pattern.match(w)
if m:
    conf.in_doc = True
    docdir = '@+at' if m.group(1) == '@' else '@+doc'
    docline = ' ' + m.group(2) if m.group(2) else ''
    yield p, joiner(conf.delim_st, docdir, docline, conf.delim_en, '\n'), True
    if conf.delim_en:
        yield p, conf.delim_st + '\n', True
    continue</t>
<t tx="vitalije.20170722133822.1">m = code_pattern.match(w)
if m:
    if conf.delim_en:
        yield p, conf.delim_en  + '\n', True
    yield p, joiner(conf.delim_st, '@', m.group(1), conf.delim_en, '\n'), True
    conf.in_doc = False
    continue</t>
<t tx="vitalije.20170722143839.1">def line_completer(it, conf):
    for p, w, final in it:
        if w:
            yield w
    yield joiner(conf.delim_st, '@-leo', conf.delim_en, '\n')
    for line in conf.last:
        yield line
@
    res = []
    for p, w, final in it:
        if w.endswith('\n') and not res:
            yield w
            continue
        res.append(w)
        if w.endswith('\n'):
            yield ''.join(res)
            res = []</t>
<t tx="vitalije.20170722144500.1">def needs_verbatim(line, conf):
    return line.lstrip().startswith(conf.delim_st + '@')</t>
<t tx="vitalije.20170722151650.1">def joiner(*args):
    try:
        return ''.join(args)
    except Exception as e:
        g.es_exception(e)
        g.trace(g.callers(10))</t>
<t tx="vitalije.20170722173013.1">def open_node(p, conf):
    conf.in_doc = False
    return  joiner(conf.delim_st, '@+node:', p.gnx,
                    star_level(p.level() - conf.zero_level),
                    p.h, conf.delim_en, '\n')</t>
<t tx="vitalije.20170722174341.1">log_it_levels = {}
def log_it(name, it):
    n = log_it_levels.get(name, 0)
    log_it_levels[name] = n + 4
    m = '%s[%s'%(' '*n, name.ljust(10))
    for p, w, final in it:
        m1 = m+'F]' if final else m + '*]'
        g.pr(m1, p.gnx, w, newline=False)
        yield p, w, final</t>
<t tx="vitalije.20170722191548.1">def test_160():
    p = prepare()
    lines = get_lines(160)
    conf = g.bunch(
        delim_st='#', delim_en='',
        in_doc=False,
        in_others=False,
        in_all=False,
        verbatim=False,
        zero_level=p.level(),
        first=True,
        count_first=0,
        last=[]
    )
    log = []
    it = all_lines(p, conf)
    it = line_completer(it, conf)
    for i, line in enumerate(lines):
        line2 = next(it,'------ None ------')
        if len(log) &gt; 4:
            log.pop(0)
        log.append((i, line, line2))
        if line != line2:
            for n, a, b in log:
                g.es(n+1, a, newline=False)
                g.es(n+1, b, color='blue', newline=False)
            return False
            for j in range(i+1, i+5):
                g.es(j, lines[j], newline=False)
                g.es(j, next(it), newline=False, color='yellow')
            return False
    return True</t>
<t tx="vitalije.20170722191554.1">def test_160_old():
    p1 = prepare()
    return g.getScript(c, p1)</t>
<t tx="vitalije.20170722191557.1">def time_test(num, func):
    t = timeit.timeit(func, number=num)
    return t/num</t>
<t tx="vitalije.20170722191602.1">def test_160_new():
    p = prepare()
    conf = g.bunch(
        delim_st='#', delim_en='',
        in_doc=False,
        in_others=False,
        in_all=False,
        verbatim=False,
        zero_level=p.level(),
        first=True,
        count_first=0,
        last=[]
    )
    it = all_lines(p, conf)
    it = line_completer(it, conf)
    s = ''.join(it)
    return s</t>
<t tx="vitalije.20170722193355.1">
.. now 2017-07-21 13:39:02.725184

Work on read derived files continues on. Right now when executing script
in `exp-4 dev` node, Leo will compare reading of almost all derived files
that could be found in Leo installation directory. Except for some 
ancient derived file formats and some files that have @+leo inside, but
are not real derived files (false_positives), all other derived files
can be successfully read by new reading code.

The only file that new reading code still can't read is activeUnitTests.txt
located in leo/test/ directory. This file contains some at-raw, and 
at-asis directives that are still not recognizable by new reading code.

.. now 21-07-2017 21:09:51

Finally, even leo/test/activeUnitTests.txt are successfully read by new code.
Now all 401 valid derived file can be read the same way as with the old code.</t>
<t tx="vitalije.20170722201021.1">def test_395():
    p = prepare395()
    lines = get_lines(395)
    conf = g.bunch(
        delim_st='#', delim_en='',
        in_doc=False,
        in_others=False,
        in_all=False,
        verbatim=False,
        zero_level=p.level(),
        first=True,
        count_first=0,
        last=[]
    )
    log = []
    it = all_lines(p, conf)
    it = line_completer(it, conf)
    for i, line in enumerate(lines):
        line2 = next(it,'------ None ------')
        if len(log) &gt; 4:
            log.pop(0)
        log.append((i, line, line2))
        if line != line2:
            for n, a, b in log:
                g.es(n+1, a, newline=False)
                g.es(n+1, b, color='blue', newline=False)
            return False
            for j in range(i+1, i+5):
                g.es(j, lines[j], newline=False)
                g.es(j, next(it), newline=False, color='yellow')
            return False
    return True</t>
<t tx="vitalije.20170722201910.1">if conf.first and not conf.in_all:
    if line.startswith('@first '):
        yield p, line[7:], True
        continue
    else:
        conf.first = False
        yield p, joiner(conf.delim_st, '@+leo-ver=5-thin', conf.delim_en, '\n'), True
        yield p, open_node(p, conf), True
        fstr = conf.delim_st + '@@first' + conf.delim_en + '\n'
        for k in range(i):
            yield p, fstr, True</t>
<t tx="vitalije.20170722202024.1">if not conf.in_all:
    if line.startswith('@last '):
        conf.last.append(line[6:])
        yield p, joiner(conf.delim_st, '@@last', conf.delim_en, '\n'), True
        continue
    elif conf.last:
        g.error('@last must be last line in body')
        break</t>
<t tx="vitalije.20170722203602.1">def atall_replacer(it, conf):
    for p, w, final in it:
        if conf.verbatim or conf.first or final:
            yield p, w, final
            continue
        if w == '@all\n':
            conf.in_all = True
            yield p, joiner(conf.delim_st, '@+all', conf.delim_en, '\n'), True
            for p1 in p.subtree_iter():
                for p2, w2, final in all_lines(p1, conf):
                    yield p2, w2, final
            w1 = joiner(conf.delim_st, '@-all', conf.delim_en, '\n')
            yield p, w1, True
            conf.in_all = False
        else:
            yield p, w, final</t>
<t tx="vitalije.20170722211247.1">conf.verbatim = needs_verbatim(line, conf)
if conf.verbatim:
    yield p, joiner(conf.delim_st, '@verbatim\n'), True
    yield p, line, False
    continue</t>
<t tx="vitalije.20170722212234.1">def test_compare_n(n, unitTesting=False):
    try:
        g.unitTesting = unitTesting
        ok, p = do_import_file(n)
        lines = get_lines(n)
        conf = get_conf(p)
        log = []
        it = all_lines(p, conf)
        it = line_completer(it, conf)
        for i, line in enumerate(lines):
            line2 = next(it,'------ None ------')
            if len(log) &gt; 4:
                log.pop(0)
            log.append((i, line, line2))
            if line != line2:
                for n, a, b in log:
                    g.es(n+1, a, newline=False)
                    g.es(n+1, b, color='blue', newline=False)
                return False
                for j in range(i+1, i+5):
                    g.es(j, lines[j], newline=False)
                    g.es(j, next(it), newline=False, color='yellow')
                return False
        return True
    finally:
        p.doDelete()
        clear_gnxDict()
        g.unitTesting = False</t>
<t tx="vitalije.20170722215608.1">def get_conf(p):
    at = c.atFileCommands
    at.scanAllDirectives(p)
    ext = g.os_path_splitext(c.getNodeFileName(p))[1].lstrip('.')
    #d = c.scanAllDirectives(p)
    #lang = d.get('language')
    # this is ugly hack, but of all files in leo distribution
    # only this one 'build-leo.bat' was not properly written
    # because computed language is 'python' when in fact it
    # should be 'batch file'
    return g.bunch(
        delim_st = at.startSentinelComment,
        delim_en = at.endSentinelComment,
        in_doc=False,
        in_others=False,
        in_all=False,
        verbatim=False,
        zero_level=p.level(),
        first=True,
        count_first=0,
        last=[]
    )</t>
<t tx="vitalije.20170723144217.1">def make_p_to_lines():
    last = []
    @others
    def p_to_lines(p, delim_st, delim_en):
        '''
           Returns iterator of lines representing the derived
           file (format version: 5-thin) of given position
           using provided delimiters.'''
        conf.delim_st = delim_st
        conf.delim_en = delim_en
        conf.in_doc=False
        conf.in_all=False
        conf.zero_level=p.level()
        for p, line, final in all_lines(p):
            yield line
        yield sent_line('@-leo')
        for line in last:
            yield line
    return p_to_lines

p_to_lines = make_p_to_lines()
p_to_lines.__module__ = __name__
p_to_lines.__qualname__ = 'p_to_lines'
p_to_lines.__name__ = 'p_to_lines'
p_to_lines.__doc__ = g.adjustTripleString(p_to_lines.__doc__, 4).strip()

del make_p_to_lines</t>
<t tx="vitalije.20170723144304.1">import itertools
import re
import leo.core.leoNodes as leoNodes
import difflib
import timeit
import pprint
from contextlib import contextmanager
from collections import deque
@others
cls()
#ok = test_compare_n(1, unclutter=False)
#ok = test_compare_n(1, unclutter=True)
errs = list()
for i, (n, fn) in enumerate(valid_files()):
    break
    ok = test_compare_n(n, unclutter=True, quiet=True)
    if not ok:
        errs.append(n)
    if i % 35 == 34:
        g.es('')
    if i == 23240:break
c.redraw()
g.es('\n finished testing')
if errs:
    g.es(errs[:5])
else:
    g.es('success')

g.es(p_to_lines)
g.es(p_to_lines.__doc__)
def count_lines(p):
    for i, line in enumerate(p_to_lines(p, '#', '')):
        pass
    else:
        return i + 1
n = count_lines(p)
f = lambda:count_lines(p)
g.es(timeit.timeit(f, number=10)/10, 'seconds')
g.es(p.h,'\n%d lines in derived file'%n)
</t>
<t tx="vitalije.20170723144431.1">def test_compare_n(n, quiet=False, unclutter=True):
    ok = False
    with testfile(n, quiet, unclutter) as p:
        lines = get_lines(n)
        conf = get_conf(p)
        log = deque(maxlen=5)
        it = p_to_lines(p, conf.delim_st, conf.delim_en)
        for i, line in enumerate(lines):
            line2 = next(it,'------ None ------')
            log.append((i, line, line2))
            if line != line2:
                ok = False
                for n, a, b in log:
                    g.es(n+1, a, newline=False)
                    g.es(n+1, b, color='blue', newline=False)
                g.es('r', repr(line))
                g.es('r', repr(line2))
                if False:
                    for j in range(i+1, i+5):
                        g.es(j, lines[j], newline=False)
                        g.es(j, next(it), newline=False, color='yellow')
                break
        else:
            ok = True
    g.es('.' if ok else 'E', newline=False)
    return ok</t>
<t tx="vitalije.20170723145133.1">def cls():
    c.frame.log.selectTab('Log')
    c.frame.log.clearLog()
def dump_diffs(diffs):
    for gnx, (d, h) in diffs.items():
        g.es(d, color='yellow')
        g.es(gnx, ':', h, color='yellow')</t>
<t tx="vitalije.20170723145151.1"></t>
<t tx="vitalije.20170723150719.1">@contextmanager
def testfile(n, quiet=True, unclutter=True):
    try:
        g.unitTesting = quiet
        ok, p = do_import_file(n)
        yield p.copy()
    except Exception as e:
        g.unitTesting = False
        g.es_exception(e)
    finally:
        g.unitTesting = False
        if unclutter:
            p.doDelete()
        clear_gnxDict()</t>
<t tx="vitalije.20170723154242.1">perfect_headlines = {
      0: "@file ../doc/leoProjects.txt",
      1: "@file ../doc/leoAttic.txt",
      2: "@file release_notes.txt",
      4: "@file leoBridge.txt",
      5: "@file zodb.txt",
      6: "@file running.txt",
      7: "@file slideshows.txt",
      8: "@file leoandotherprograms.txt",
      9: "@file testimonials.txt",
     10: "@file ../doc/leoToDo.txt",
     11: "@file vimBindings.txt",
     12: "@file usersguide.txt",
     13: "@file whatsnew.txt",
     14: "@thin slides.txt",
     15: "@file rstplugin3.txt",
     16: "@file debuggers.txt",
     17: "@file customizing.txt",
     19: "@file appendices.txt",
     20: "@file unitTesting.txt",
     22: "@file ../doc/leoToDoLater.txt",
     23: "@file nutshell.txt",
     24: "@file design.txt",
     25: "@file cheatsheet.txt",
     26: "@file preface.txt",
     27: "@file outline-commands.txt",
     29: "@file intermediatetopics.txt",
     30: "@file preliminaries.txt",
     31: "@file download.txt",
     32: "@file ../doc/leoNotes.txt",
     33: "@file FAQ.txt",
     34: "@file html/index.html",
     35: "@file frontMatter.txt",
     36: "@file glossary.txt",
     37: "@file atShadow.txt",
     38: "@file plugin_catalog.py",
     39: "@file coloring.txt",
     40: "@file intro.txt",
     41: "@file screen-shots.txt",
     42: "@file plugins.txt",
     43: "@file outlines.txt",
     44: "@file commands.txt",
     45: "@file IpythonBridge.txt",
     46: "@file emacs.txt",
     47: "@file leo.rst",
     48: "@file index.rst",
     49: "@file requirements.txt",
     50: "@file leo.plugins.pygeotag.rst",
     51: "@file leo.plugins.rst",
     52: "@file leo.external.rst",
     53: "@file leo.external.concurrent.rst",
     54: "@file Makefile",
     55: "@file make.bat",
     56: "@file leo.core.rst",
     57: "@file leo.external.concurrent.futures.rst",
     58: "@file conf.py",
     59: "@file leo.extensions.rst",
     60: "@file tutorial.txt",
     61: "@file writingPlugins.txt",
     62: "@file installing.txt",
     63: "@file build-leo.bat",
     65: "@file unregister-leo.leox",
     66: "@file register-leo.leox",
     67: "@file elevate.py",
     68: "@file gen_blender_docs.py",
     69: "@file leoScripts.txt",
     72: "@file ../external/obsolete/ipy_leo.py",
     73: "@file ../external/lproto.py",
     74: "@file ../external/npyscreen/npysNPSFilteredData.py",
     75: "@file ../external/npyscreen/wgboxwidget.py",
     76: "@file ../external/npyscreen/proto_fm_screen_area.py",
     77: "@file ../external/npyscreen/wgeditmultiline.py",
     78: "@file ../external/npyscreen/wgtexttokens.py",
     79: "@file ../external/npyscreen/npyssafewrapper.py",
     80: "@file ../external/npyscreen/wgtextbox_controlchrs.py",
     81: "@file ../external/npyscreen/npysThemes.py",
     82: "@file ../external/npyscreen/apNPSApplication.py",
     83: "@file ../external/npyscreen/wgwidget_proto.py",
     84: "@file ../external/npyscreen/wgautocomplete.py",
     85: "@file ../external/npyscreen/wgtextbox.py",
     86: "@file ../external/npyscreen/apNPSApplicationManaged.py",
     87: "@file ../external/npyscreen/wgNMenuDisplay.py",
     88: "@file ../external/npyscreen/wgpassword.py",
     89: "@file ../external/npyscreen/fmFormMultiPage.py",
     90: "@file ../external/npyscreen/globals.py",
     91: "@file ../external/npyscreen/wgmultilinetreeselectable.py",
     92: "@file ../external/npyscreen/wggridcoltitles.py",
     93: "@file ../external/npyscreen/apNPSApplicationEvents.py",
     94: "@file ../external/npyscreen/eveventhandler.py",
     95: "@file ../external/npyscreen/npysTree.py",
     96: "@file ../external/npyscreen/wgtitlefield.py",
     97: "@file ../external/npyscreen/npysThemeManagers.py",
     98: "@file ../external/npyscreen/fm_form_edit_loop.py",
     99: "@file ../external/npyscreen/__init__.py",
    100: "@file ../external/npyscreen/fmActionFormV2.py",
    101: "@file ../external/npyscreen/wgselectone.py",
    102: "@file ../external/npyscreen/npyspmfuncs.py",
    103: "@file ../external/npyscreen/fmFormMuttActive.py",
    104: "@file ../external/npyscreen/wgmonthbox.py",
    105: "@file ../external/npyscreen/apNPSApplicationAdvanced.py",
    106: "@file ../external/npyscreen/fmFileSelector.py",
    107: "@file ../external/npyscreen/wgcombobox.py",
    108: "@file ../external/npyscreen/wgmultilinetree.py",
    109: "@file ../external/npyscreen/muMenu.py",
    110: "@file ../external/npyscreen/utilNotify.py",
    111: "@file ../external/npyscreen/wgmultilineeditable.py",
    112: "@file ../external/npyscreen/fmFormMutt.py",
    113: "@file ../external/npyscreen/wgcheckbox.py",
    114: "@file ../external/npyscreen/wgwidget.py",
    115: "@file ../external/npyscreen/wgslider.py",
    116: "@file ../external/npyscreen/apOptions.py",
    117: "@file ../external/npyscreen/wgmultiselect.py",
    118: "@file ../external/npyscreen/fmFormWithMenus.py",
    119: "@file ../external/npyscreen/muNewMenu.py",
    120: "@file ../external/npyscreen/wgFormControlCheckbox.py",
    121: "@file ../external/npyscreen/fmActionForm.py",
    122: "@file ../external/npyscreen/util_viewhelp.py",
    123: "@file ../external/npyscreen/wggrid.py",
    124: "@file ../external/npyscreen/wgfilenamecombo.py",
    125: "@file ../external/npyscreen/fmPopup.py",
    126: "@file ../external/npyscreen/wgmultiline.py",
    127: "@file ../external/npyscreen/wgmultiselecttree.py",
    128: "@file ../external/npyscreen/wgbutton.py",
    129: "@file ../external/npyscreen/wgdatecombo.py",
    130: "@file ../external/npyscreen/wgannotatetextbox.py",
    131: "@file ../external/npyscreen/npysGlobalOptions.py",
    132: "@file ../external/npyscreen/wgtextboxunicode.py",
    133: "@file ../external/npyscreen/stdfmemail.py",
    134: "@file ../external/npyscreen/fmForm.py",
    136: "@file ../external/leosax.py",
    137: "@file ../external/log_listener.py",
    139: "@file ../external/edb.py",
    140: "@file ../external/py2cs.py",
    141: "@file ../external/make_stub_files.py",
    142: "@file ../external/log_broadcast.py",
    143: "@file ../external/codewise.py",
    144: "@file ../external/leoSAGlobals.py",
    145: "@thin format-code.py",
    146: "@file leoImport.py",
    147: "@file leoPrinting.py",
    148: "@file leoBridgeTest.py",
    149: "@file leoApp.py",
    150: "@file leoUndo.py",
    151: "@file leoDynamicTest.py",
    152: "@file leoFileCommands.py",
    153: "@file leoTangle.py",
    154: "@file leoTest.py",
    155: "@file leoVim.py",
    156: "@file leoQt.py",
    157: "@file leoIPython.py",
    158: "@file leoCompare.py",
    159: "@file leoSessions.py",
    160: "@file leoGlobals.py",
    161: "@file leoFind.py",
    162: "@file leoMenu.py",
    163: "@file leoCheck.py",
    164: "@file leoGui.py",
    165: "@file leoBackground.py",
    166: "@file leoPlugins.py",
    167: "@file leoAst.py",
    168: "@file leoNodes.py",
    169: "@file leoCommands.py",
    170: "@file leoHistory.py",
    171: "@file leoVersion.py",
    172: "@file leoPersistence.py",
    173: "@file leoConfig.py",
    174: "@file leoCache.py",
    175: "@file leoRst.py",
    176: "@file leoBeautify.py",
    177: "@file leoPymacs.py",
    178: "@file leoExternalFiles.py",
    179: "@file leoChapters.py",
    180: "@file leoAtFile.py",
    181: "@file leoKeys.py",
    182: "@file leoShadow.py",
    184: "@file runLeo.py",
    185: "@file leoColorizer.py",
    187: "@file leoBridge.py",
    189: "@file leoDebugger.py",
    190: "@file leoColor.py",
    191: "@file leoFrame.py",
    192: "@file leoRope.py",
    195: "@file mod_speedups.py",
    196: "@file ./obsolete/ironPythonGui.py",
    199: "@file ./obsolete/swing_gui.py",
    200: "@file ./obsolete/tkGui.py",
    201: "@file ./obsolete/wxGui.py",
    202: "@file ../plugins/qt_frame.py",
    203: "@file ctagscompleter.py",
    204: "@file leomylyn.py",
    205: "@file ftp.py",
    206: "@file nodewatch.py",
    207: "@file ../plugins/nested_splitter.py",
    208: "@file macros.py",
    209: "@file livecode.py",
    210: "@file interact.py",
    211: "@file multifile.py",
    212: "@file slideshow.py",
    213: "@file notebook.py",
    214: "@file leoPluginNotes.txt",
    215: "@file sftp.py",
    216: "@file screenshots.py",
    217: "@file plugins_menu.py",
    218: "@file xml_edit.py",
    219: "@file outline_export.py",
    220: "@file startfile.py",
    221: "@file graphcanvas.py",
    222: "@file scripts_menu.py",
    223: "@file quicksearch.py",
    224: "@file viewrendered2.py",
    225: "@file ../plugins/qt_text.py",
    226: "@file template_gui.py",
    227: "@file colorize_headlines.py",
    228: "@file python_terminal.py",
    229: "@file stickynotes.py",
    231: "@file ../plugins/qt_tree.py",
    232: "@file demo.py",
    233: "@file setHomeDirectory.py",
    234: "@file nodetags.py",
    235: "@file script_io_to_body.py",
    236: "@file auto_colorize2_0.py",
    237: "@file leo_to_rtf.py",
    238: "@file chapter_hoist.py",
    239: "@file xemacs.py",
    240: "@file niceNosent.py",
    241: "@file word_count.py",
    242: "@file quickMove.py",
    243: "@file tomboy_import.py",
    244: "@file mod_read_dir_outline.py",
    245: "@file ../plugins/qt_gui.py",
    246: "@file timestamp.py",
    247: "@file leomail.py",
    248: "@file expfolder.py",
    249: "@file dtest.py",
    250: "@file xsltWithNodes.py",
    251: "@file rss.py",
    252: "@file bzr_qcommands.py",
    253: "@file leo_interface.py",
    254: "@file leofeeds.py",
    256: "@file at_produce.py",
    257: "@file leoremote.py",
    258: "@file mod_scripting.py",
    259: "@file mod_autosave.py",
    260: "@file run_nodes.py",
    261: "@file todo.py",
    262: "@file markup_inline.py",
    263: "@file importers/python.py",
    264: "@file importers/ini.py",
    265: "@file importers/coffeescript.py",
    266: "@file importers/typescript.py",
    267: "@file importers/csharp.py",
    268: "@file importers/linescanner.py",
    269: "@file importers/ipynb.py",
    270: "@file importers/leo_rst.py",
    271: "@file importers/__init__.py",
    272: "@file importers/java.py",
    273: "@file importers/xml.py",
    274: "@file importers/markdown.py",
    275: "@file importers/c.py",
    276: "@file importers/javascript.py",
    277: "@file importers/dart.py",
    278: "@file importers/perl.py",
    279: "@file importers/pascal.py",
    280: "@file importers/php.py",
    281: "@file importers/html.py",
    282: "@file importers/org.py",
    283: "@file importers/lua.py",
    284: "@file importers/otl.py",
    285: "@file importers/elisp.py",
    286: "@file importers/json.py",
    287: "@file importers/tcl.py",
    288: "@file importers/ctext.py",
    289: "@file mod_timestamp.py",
    290: "@file gitarchive.py",
    291: "@file dump_globals.py",
    292: "@file mod_leo2ascd.txt",
    293: "@file screencast.py",
    294: "@file debugger_pudb.py",
    295: "@file ../plugins/qt_commands.py",
    297: "@file writers/basewriter.py",
    298: "@file writers/ipynb.py",
    299: "@file writers/leo_rst.py",
    300: "@file writers/__init__.py",
    301: "@file writers/markdown.py",
    302: "@file writers/dart.py",
    303: "@file writers/test.py",
    304: "@file writers/org.py",
    305: "@file writers/otl.py",
    306: "@file writers/json.py",
    307: "@file writers/ctext.py",
    308: "@file pretty_print.py",
    309: "@file stickynotes_plus.py",
    310: "@file viewrendered.py",
    311: "@file mod_http.py",
    312: "@file at_view.py",
    313: "@file trace_gc_plugin.py",
    314: "@file bookmarks.py",
    315: "@file projectwizard.py",
    316: "@file jinjarender.py",
    317: "@file ../plugins/qtGui.py",
    319: "@file read_only_nodes.py",
    320: "@file pyplot_backend.py",
    322: "@file rst3.py",
    323: "@file contextmenu.py",
    324: "@file import_cisco_config.py",
    325: "@file cursesGui.py",
    326: "@file dragdropgoodies.py",
    327: "@file add_directives.py",
    328: "@file leocursor.py",
    329: "@file empty_leo_file.py",
    330: "@file testRegisterCommand.py",
    331: "@file datenodes.py",
    332: "@file bigdash.py",
    333: "@file qtNotes.txt",
    334: "@file at_folder.py",
    335: "@file leoscreen.py",
    336: "@file backlink.py",
    337: "@file open_shell.py",
    338: "@file ../plugins/qt_idle_time.py",
    339: "@file maximizeNewWindows.py",
    340: "@file test/failed_import.py",
    341: "@file test/failed_to_load_plugin.py",
    342: "@file test/syntax_error_plugin.py",
    343: "@file test/ekr_test.py",
    344: "@file trace_tags.py",
    345: "@file ../plugins/free_layout.py",
    346: "@file nodeActions.py",
    347: "@file cursesGui2.py",
    348: "@file spydershell.py",
    349: "@file leoOPML.py",
    350: "@file nodediff.py",
    351: "@file threadutil.py",
    352: "@file leo_to_html.py",
    353: "@file ../plugins/baseNativeTree.py",
    354: "@file initinclass.py",
    355: "@file redirect_to_log.py",
    356: "@file enable_gc.py",
    357: "@file attrib_edit.py",
    358: "@file FileActions.py",
    359: "@file trace_keys.py",
    360: "@file mime.py",
    361: "@file wikiview.py",
    362: "@file bibtex.py",
    363: "@file mod_leo2ascd.py",
    364: "@file settings_finder.py",
    365: "@file systray.py",
    366: "@file tables.py",
    367: "@file geotag.py",
    368: "@file mnplugins.py",
    369: "@file zenity_file_dialogs.py",
    370: "@file richtext.py",
    371: "@file examples/override_classes.py",
    372: "@file examples/redefine_put.py",
    373: "@file examples/chinese_menu.py",
    374: "@file examples/print_cp.py",
    375: "@file examples/french_fm.py",
    376: "@file examples/override_commands.py",
    377: "@file screen_capture.py",
    378: "@file ../plugins/qt_quickheadlines.py",
    379: "@file quit_leo.py",
    380: "@file vim.py",
    381: "@file codewisecompleter.py",
    382: "@file nav_qt.py",
    383: "@file ../plugins/qt_events.py",
    384: "@file leo_pdf.py",
    385: "@file textnode.py",
    386: "@file mod_framesize.py",
    387: "@file paste_as_headlines.py",
    388: "@file valuespace.py",
    389: "@file word_export.py",
    390: "@file active_path.py",
    391: "@file lineNumbers.py",
    392: "@file ../../setup.py",
    393: "@file inactiveTests.txt",
    395: "@file activeUnitTests.txt",
    396: "@thin unittest/at-thin-line-number-test.py",
    398: "@thin unittest/batchTest.py",
    399: "@thin ../test/unittest/at-path-test1.py",
    400: "@thin at-path-test3.py",
    401: "@thin at-path-test2.py",
    402: "@file unittest/at-file-line-number-test.py",
    403: "@thin unittest/at-thin-test.py",
    404: "@thin unittest/at-thin-html-test.html",
    405: "@file unittest/tex-error.tex",
    410: "@file unittest/at-file-line-number-test.c",
    411: "@thin unittest/errorTest.py",
    414: "@file unitTestStartup.txt",
    415: "@file ../commands/killBufferCommands.py",
    416: "@file ../commands/baseCommands.py",
    417: "@file ../commands/convertCommands.py",
    418: "@file ../commands/abbrevCommands.py",
    419: "@file ../commands/controlCommands.py",
    420: "@file ../commands/searchCommands.py",
    421: "@file ../commands/spellCommands.py",
    422: "@file ../commands/gotoCommands.py",
    423: "@file ../commands/checkerCommands.py",
    424: "@file ../commands/debugCommands.py",
    425: "@file ../commands/helpCommands.py",
    426: "@file ../commands/keyCommands.py",
    427: "@file ../commands/bufferCommands.py",
    428: "@file ../commands/rectangleCommands.py",
    429: "@file ../commands/editFileCommands.py",
    430: "@file ../commands/editCommands.py",
}</t>
<t tx="vitalije.20170723154327.1">def do_import_file(j):
    p1 = c.find_h('EXTERNALS')[0]
    p2 = p1.insertAsLastChild()
    fn = derived_files[j]
    p1.b = '@path %s'%ideal_path_for_import(j)
    hfi = perfect_headlines[j]
    p2.h = hfi
    gnx = p2.gnx
    pth = c.getNodeFileName(p2)
    fn2 = fn.replace('/', '\\')
    assert pth in (fn, fn2), '%d \n%s !=\n%s\n%s'%(j, pth, fn, hfi)
    ok = c.atFileCommands.read(p2, force=True)
    gnx2 = p2.gnx
    if gnx != gnx2:
        c.fileCommands.gnxDict[gnx2] = p2.v
        c.fileCommands.gnxDict.pop(gnx)
    p2.contract()
    return ok,p2</t>
<t tx="vitalije.20170723155348.2">@others
patterns = get_patterns(delim_st, delim_en)</t>
<t tx="vitalije.20170723160205.1">@
    Initial configuration. Values are not important because they will be
    overriden once the p_to_lines get invoked.
@c
conf = g.bunch(
    delim_st='#',
    delim_en='',
    in_doc=False, 
    in_others=False,
    in_all=False,
    zero_level=0)
</t>
<t tx="vitalije.20170723163543.1">if g.isPython3:
    from functools import lru_cache as cache, wraps
else:
    from functools import wraps
    def cache(func):
        saved = {}
        @wraps(func)
        def newfunc(*args):
            if args in saved:
                return saved[args]
            result = func(*args)
            saved[args] = result
            return result
        return newfunc</t>
<t tx="vitalije.20170723163600.1"></t>
<t tx="vitalije.20170723163726.10">def others_iterator(p):
    after = p.nodeAfterTree()
    p1 = p.threadNext()
    while p1 and p1 != after:
        if p1.isAtIgnoreNode() or section_ref(p1.h)[1]:
            p1.moveToNodeAfterTree()
        else:
            yield p1.copy()
            if others_pat.search(p1.b):
                p1.moveToNodeAfterTree()
            else:
                p1.moveToThreadNext()
</t>
<t tx="vitalije.20170723163726.11">def section_replacer(it):
    for p, w, final in it:
        if final:
            yield p, w, final
            continue
        indent, sref, after = section_ref(w)
        if sref and not conf.in_doc:
            if conf.in_all:
                yield p, w, True
            else:
                p1 = g.findReference(sref, p)
                if not p1:
                    raise LookupError('unresolved section reference: %s'%w)
                yield p, sent_line('@+', sref, indent=indent), True
                for p2, w2, final in all_lines(p1):
                    w2 = indent + w2 if w2 != '\n' else w2
                    yield p2, w2, final
                yield p, sent_line('@-', sref, after, indent=indent), True
                conf.in_doc = False
        else:
            yield p, w, final
</t>
<t tx="vitalije.20170723163726.13">def open_node(p):
    stlev = star_level(p.level() - conf.zero_level)
    return  sent_line('@+node:', p.gnx, stlev, p.h)</t>
<t tx="vitalije.20170723163726.14">def body_lines(p):
    first = p.level() == conf.zero_level
    if not first:
        yield p, open_node(p), True
    conf.in_doc = False
    if p.b:
        for i, line in enumerate(g.splitLines(p.b)):
            # child nodes should use continue
            # if they need to skip following nodes
            @others
            yield p, line, False
        if not line.endswith('\n'):
            yield p, '\n', False
</t>
<t tx="vitalije.20170723163726.15">verbatim = needs_verbatim(line)
if verbatim:
    yield p, sent_line('@verbatim'), True
    yield p, line, True
    continue</t>
<t tx="vitalije.20170723163726.16">if first:
    if line.startswith('@first '):
        yield p, line[7:], True
        continue
    else:
        first = False
        yield p, sent_line('@+leo-ver=5-thin'), True
        yield p, open_node(p), True
        fstr = sent_line('@@first')
        for k in range(i):
            yield p, fstr, True
</t>
<t tx="vitalije.20170723163726.17">if not conf.in_all:
    if line.startswith('@last '):
        last.append(line[6:])
        yield p, sent_line('@@last'), True
        continue
    elif last:
        g.error('@last must be last line in body')
        break</t>
<t tx="vitalije.20170723163726.18">def needs_verbatim(line):
    return line.lstrip().startswith(conf.delim_st + '@')</t>
<t tx="vitalije.20170723163726.19">def others_replacer(it):
    for p, w, final in it:
        if final:
            yield p, w, final
            continue
        m = others_pat.match(w)
        if m and not conf.in_doc:
            if conf.in_all:
                yield p, w, True
            else:
                indent = m.group(1)
                w1 = sent_line('@+others',indent=indent)
                yield p, w1, True
                for p1 in others_iterator(p):
                    for p2, w2, final in all_lines(p1):
                        w2 = indent + w2 if w2 != '\n' else w2
                        yield p2, w2, final
                yield p, sent_line('@-others',indent=indent), True
                conf.in_doc = False
        else:
            yield p, w, final</t>
<t tx="vitalije.20170723163726.20">def atall_replacer(it):
    for p, w, final in it:
        if final:
            yield p, w, final
            continue
        if w == '@all\n':
            conf.in_all = True
            conf.in_doc = False
            yield p, sent_line('@+all'), True
            for p1 in p.subtree_iter():
                for p2, w2, final in all_lines(p1):
                    yield p2, w2, final
            yield p, sent_line('@-all'), True
            conf.in_all = False
            conf.in_doc = False
        else:
            yield p, w, final</t>
<t tx="vitalije.20170723163726.21">log_it_levels = {}
def log_it(name, it):
    n = log_it_levels.get(name, 0)
    log_it_levels[name] = n + 4
    m = '%s[%s'%(' '*n, name.ljust(10))
    for p, w, final in it:
        m1 = m+'F]' if final else m + '*]'
        g.pr(m1, p.gnx, w, newline=False)
        yield p, w, final</t>
<t tx="vitalije.20170723163726.22">def all_lines(p):
    trace = False
    if trace:
        it = body_lines(p)
        it = log_it('body_lines', it)
        it = atall_replacer(it)
        it = log_it('all_repl', it)
        it = section_replacer(it)
        it = log_it('sec_repl', it)
        it = others_replacer(it)
        it = log_it('oth_repl', it)
        it = at_adder(it)
        it = log_it('at_adder', it)
        it = at_docer(it)
        it = log_it('at_docer', it)
    else:
        it = body_lines(p)
        it = atall_replacer(it)
        it = section_replacer(it)
        it = others_replacer(it)
        it = at_adder(it)
        it = at_docer(it)
    return it
</t>
<t tx="vitalije.20170723163726.23">def at_docer(it):
    for p, w, final in it:
        if final or conf.in_all:
            yield p, w, final
            continue
        @others
        if conf.in_doc and not conf.delim_en:
            yield p, sent_line(' ', w[:-1]), True
        else:
            yield p, w, False</t>
<t tx="vitalije.20170723163726.24">m = doc_pattern.match(w)
if m:
    conf.in_doc = True
    docdir = '@+at' if m.group(1) == '@' else '@+doc'
    docline = ' ' + m.group(2) if m.group(2) else ''
    yield p, sent_line(docdir, docline), True
    if conf.delim_en:
        yield p, conf.delim_st + '\n', True
    continue</t>
<t tx="vitalije.20170723163726.25">m = code_pattern.match(w)
if m:
    if conf.delim_en:
        yield p, conf.delim_en  + '\n', True
    yield p, sent_line('@', m.group(1)), True
    conf.in_doc = False
    continue</t>
<t tx="vitalije.20170723163726.26">def at_adder(it):
    for p, w, final in it:
        if final:
            yield p, w, final
            continue
        m = atdir_pat.match(w)
        if m and not conf.in_all:
            yield p, sent_line('@', w[:-1]), True
        else:
            yield p, w, False</t>
<t tx="vitalije.20170723163726.27">def star_level(lev):
    if lev &lt; 2:
        return [': * ', ': ** '][lev]
    else:
        return ': *%d* '%(lev + 1)</t>
<t tx="vitalije.20170723163726.6">def section_ref(s):
    m = section_pat.match(s)
    if m:
        return m.groups()
    return None, None, None</t>
<t tx="vitalije.20170723164028.1">section_pat = re.compile(r'^(\s*)(&lt;{2}[^&gt;]+&gt;&gt;)(.*)$')

others_pat = re.compile(r'^(\s*)@others\b', re.M)
    # !important re.M used also in others_iterator

doc_pattern = re.compile('^(@doc|@)(?:\\s(.*?)\n|\n)$')

code_pattern = re.compile('^(@code|@c)$')


# TODO: check if there are more directives that
#       should be in this pattern
atdir_pat = re.compile('^@('
    'beautify|'
    'color|'
    'encoding|'
    'killbeautify|'
    'killcolor|'
    'language|'
    'last|'
    'nobeautify|'
    'nocolor-node|'
    'nocolor|'
    'nosearch|'
    'pagewidth|'
    'path|'
    'root|'
    'tabwidth|'
    'wrap)')
</t>
<t tx="vitalije.20170723171549.1">def sent_line(s1, s2='', s3='', s4='', indent=''):
    return ''.join((indent,conf.delim_st, s1, s2, s3, s4, conf.delim_en, '\n'))</t>
<t tx="vitalije.20170723192208.1"></t>
<t tx="vitalije.20170723192228.1"></t>
<t tx="vitalije.20170723192228.2"></t>
<t tx="vitalije.20170723192228.3"></t>
<t tx="vitalije.20170724100819.1">
22-07-2017 19:37:01

Working on write code. At present generating lines of leo/core/leoGlobals.py
works as expected (same as leoAtFile.py). Next task will be to try generating
lines of leo/test/activeUnitTests.txt which seems to be most chalenging file
in Leo distribution.

22-07-2017 21:20:09
Writing leo/test/activeUnitTests.txt with new code working properly.


22-07-2017 22:55:49
Writing all derived files from leo installation directory, using new code
gives the same result as the old code.</t>
<t tx="vitalije.20170724101716.1">24-07-2017 10:08:41

Yesterday I have reformulated the whole suite of **Write code**, all helper
functions are now inside one function that create all those helpers and at
the end returns one function as the entry point in to this code. It is not
turned into a class as Edward suggested. I like more this style that I learned
in coffeescript and clojurescript. I am not sure whether there are some performance
penalties caused by this approach.

</t>
<t tx="vitalije.20170724101826.1">import itertools
import re
import leo.core.leoNodes as leoNodes
import difflib
import timeit
import pprint
from contextlib import contextmanager
from collections import deque, Counter
@others
cls()
#test_works_ok()
#test_works_ok2()
profile_this(169, 100)
g.es('the end')</t>
<t tx="vitalije.20170724102025.1">def p_to_lines(p, delim_st, delim_en):
    '''Returns iterator of lines representing the derived
       file (format version: 5-thin) of given position
       using provided delimiters.'''
    last = []
    @others

    for p, line, final in all_lines(p):
        yield line
    yield sent_line('@-leo')
    for line in last:
        yield line
</t>
<t tx="vitalije.20170724102025.10">if first:
    if line.startswith('@first '):
        yield p, line[7:], True
        continue
    else:
        first = False
        yield p, sent_line('@+leo-ver=5-thin'), True
        yield p, open_node(p), True
        fstr = sent_line('@@first')
        for k in range(i):
            yield p, fstr, True
</t>
<t tx="vitalije.20170724102025.11">if not conf.in_all:
    if line.startswith('@last '):
        last.append(line[6:])
        yield p, sent_line('@@last'), True
        continue
    elif last:
        g.error('@last must be last line in body')
        break</t>
<t tx="vitalije.20170724102025.12">def needs_verbatim(line):
    return line.lstrip().startswith(conf.delim_st + '@')</t>
<t tx="vitalije.20170724102025.13">def others_replacer(it):
    for p, w, final in it:
        if final:
            yield p, w, final
            continue
        m = others_pat.match(w)
        if m and not conf.in_doc:
            if conf.in_all:
                yield p, w, True
            else:
                indent = m.group(1)
                w1 = sent_line('@+others',indent=indent)
                yield p, w1, True
                for p1 in others_iterator(p):
                    for p2, w2, final in all_lines(p1):
                        w2 = indent + w2 if w2 != '\n' else w2
                        yield p2, w2, final
                yield p, sent_line('@-others',indent=indent), True
                conf.in_doc = False
        else:
            yield p, w, final</t>
<t tx="vitalije.20170724102025.14">def atall_replacer(it):
    for p, w, final in it:
        if final:
            yield p, w, final
            continue
        if w == '@all\n':
            conf.in_all = True
            conf.in_doc = False
            yield p, sent_line('@+all'), True
            for p1 in p.subtree_iter():
                for p2, w2, final in all_lines(p1):
                    yield p2, w2, final
            yield p, sent_line('@-all'), True
            conf.in_all = False
            conf.in_doc = False
        else:
            yield p, w, final</t>
<t tx="vitalije.20170724102025.15">log_it_levels = {}
def log_it(name, it):
    n = log_it_levels.get(name, 0)
    log_it_levels[name] = n + 4
    m = '%s[%s'%(' '*n, name.ljust(10))
    for p, w, final in it:
        m1 = m+'F]' if final else m + '*]'
        g.pr(m1, p.gnx, w, newline=False)
        yield p, w, final</t>
<t tx="vitalije.20170724102025.16">def all_lines(p):
    trace = False
    if trace:
        it = body_lines(p)
        it = log_it('body_lines', it)
        it = atall_replacer(it)
        it = log_it('all_repl', it)
        it = section_replacer(it)
        it = log_it('sec_repl', it)
        it = others_replacer(it)
        it = log_it('oth_repl', it)
        it = at_adder(it)
        it = log_it('at_adder', it)
        it = at_docer(it)
        it = log_it('at_docer', it)
    else:
        it = body_lines(p)
        it = atall_replacer(it)
        it = section_replacer(it)
        it = others_replacer(it)
        it = at_adder(it)
        it = at_docer(it)
    return it
</t>
<t tx="vitalije.20170724102025.17">def at_docer(it):
    for p, w, final in it:
        if final or conf.in_all:
            yield p, w, final
            continue
        @others
        if conf.in_doc and not conf.delim_en:
            yield p, sent_line(' ', w[:-1]), True
        else:
            yield p, w, False</t>
<t tx="vitalije.20170724102025.18">m = doc_pattern.match(w)
if m:
    conf.in_doc = True
    docdir = '@+at' if m.group(1) == '@' else '@+doc'
    docline = ' ' + m.group(2) if m.group(2) else ''
    yield p, sent_line(docdir, docline), True
    if conf.delim_en:
        yield p, conf.delim_st + '\n', True
    continue</t>
<t tx="vitalije.20170724102025.19">m = code_pattern.match(w)
if m:
    if conf.delim_en:
        yield p, conf.delim_en  + '\n', True
    yield p, sent_line('@', m.group(1)), True
    conf.in_doc = False
    continue</t>
<t tx="vitalije.20170724102025.2">conf = g.bunch(
    delim_st=delim_st,
    delim_en=delim_en,
    in_doc=False, 
    in_all=False,
    zero_level=p.level())
</t>
<t tx="vitalije.20170724102025.20">def at_adder(it):
    for p, w, final in it:
        if final:
            yield p, w, final
            continue
        m = atdir_pat.match(w)
        if m and not conf.in_all:
            yield p, sent_line('@', w[:-1]), True
        else:
            yield p, w, False</t>
<t tx="vitalije.20170724102025.21">def star_level(lev):
    if lev &lt; 2:
        return [': * ', ': ** '][lev]
    else:
        return ': *%d* '%(lev + 1)</t>
<t tx="vitalije.20170724102025.22">def sent_line(s1, s2='', s3='', s4='', indent=''):
    return ''.join((indent,conf.delim_st, s1, s2, s3, s4, conf.delim_en, '\n'))</t>
<t tx="vitalije.20170724102025.3">section_pat = re.compile(r'^(\s*)(&lt;{2}[^&gt;]+&gt;&gt;)(.*)$')

others_pat = re.compile(r'^(\s*)@others\b', re.M)
    # !important re.M used also in others_iterator

doc_pattern = re.compile('^(@doc|@)(?:\\s(.*?)\n|\n)$')

code_pattern = re.compile('^(@code|@c)$')


# TODO: check if there are more directives that
#       should be in this pattern
atdir_pat = re.compile('^@('
    'beautify|'
    'color|'
    'encoding|'
    'killbeautify|'
    'killcolor|'
    'language|'
    'last|'
    'nobeautify|'
    'nocolor-node|'
    'nocolor|'
    'nosearch|'
    'pagewidth|'
    'path|'
    'root|'
    'tabwidth|'
    'wrap)')
</t>
<t tx="vitalije.20170724102025.4">def section_ref(s):
    m = section_pat.match(s)
    if m:
        return m.groups()
    return None, None, None</t>
<t tx="vitalije.20170724102025.5">def others_iterator(p):
    after = p.nodeAfterTree()
    p1 = p.threadNext()
    while p1 and p1 != after:
        if p1.isAtIgnoreNode() or section_ref(p1.h)[1]:
            p1.moveToNodeAfterTree()
        else:
            yield p1.copy()
            if others_pat.search(p1.b):
                p1.moveToNodeAfterTree()
            else:
                p1.moveToThreadNext()
</t>
<t tx="vitalije.20170724102025.6">def section_replacer(it):
    for p, w, final in it:
        if final:
            yield p, w, final
            continue
        indent, sref, after = section_ref(w)
        if sref and not conf.in_doc:
            if conf.in_all:
                yield p, w, True
            else:
                p1 = g.findReference(sref, p)
                if not p1:
                    raise LookupError('unresolved section reference: %s'%w)
                yield p, sent_line('@+', sref, indent=indent), True
                for p2, w2, final in all_lines(p1):
                    w2 = indent + w2 if w2 != '\n' else w2
                    yield p2, w2, final
                yield p, sent_line('@-', sref, after, indent=indent), True
                conf.in_doc = False
        else:
            yield p, w, final
</t>
<t tx="vitalije.20170724102025.7">def open_node(p):
    stlev = star_level(p.level() - conf.zero_level)
    return  sent_line('@+node:', p.gnx, stlev, p.h)</t>
<t tx="vitalije.20170724102025.8">def body_lines(p):
    first = p.level() == conf.zero_level
    if not first:
        yield p, open_node(p), True
    conf.in_doc = False
    if p.b:
        for i, line in enumerate(g.splitLines(p.b)):
            # child nodes should use continue
            # if they need to skip following nodes
            @others
            yield p, line, False
        if not line.endswith('\n'):
            yield p, '\n', False
</t>
<t tx="vitalije.20170724102025.9">verbatim = needs_verbatim(line)
if verbatim:
    yield p, sent_line('@verbatim'), True
    yield p, line, True
    continue</t>
<t tx="vitalije.20170724105412.1">def test_works_ok():
    errs = list()
    for i, (n, fn) in enumerate(valid_files()):
        ok = test_compare_n(n, unclutter=True, quiet=True)
        if not ok:
            errs.append(n)
        if i % 35 == 34:
            g.es('')
        if i == 23240:break
    c.redraw()
    g.es('\n finished testing')
    if errs:
        g.es(errs[:5])
    else:
        g.es('success')</t>
<t tx="vitalije.20170724105417.1">def profile_this(n, num):
    with testfile(n, quiet=False,  unclutter=True) as p:
        def p_to_text():
            return ''.join(p_to_lines(p, '#', ''))
        def p_to_text2():
            dfw = DerivedFileWriter(c, p, '#', '')
            return ''.join(dfw.to_lines())

        ms = 1000*timeit.timeit(p_to_text, number=num)/num
        g.es('v1: average time: %4.1f ms'%ms)

        ms = 1000*timeit.timeit(p_to_text2, number=num)/num
        g.es('v2: average time: %4.1f ms'%ms)</t>
<t tx="vitalije.20170724105617.1">class DerivedFileWriter:
    @others
</t>
<t tx="vitalije.20170724110122.1">def __init__(self, c, p, delim_st, delim_en):
    self.c = c
    self.p = p
    self.delim_st = delim_st
    self.delim_en = delim_en
    self.in_doc = False
    self.in_all = False
    self.zero_level = p.level()
    section_pat = re.compile(r'^(\s*)(&lt;{2}[^&gt;]+&gt;&gt;)(.*)$')

    others_pat = re.compile(r'^(\s*)@others\b', re.M)
        # !important re.M used also in others_iterator

    doc_pattern = re.compile('^(@doc|@)(?:\\s(.*?)\n|\n)$')

    code_pattern = re.compile('^(@code|@c)$')

    # TODO: check if there are more directives that
    #       should be in this pattern
    atdir_pat = re.compile('^@('
        'beautify|'
        'color|'
        'encoding|'
        'killbeautify|'
        'killcolor|'
        'language|'
        'last|'
        'nobeautify|'
        'nocolor-node|'
        'nocolor|'
        'nosearch|'
        'pagewidth|'
        'path|'
        'root|'
        'tabwidth|'
        'wrap)')
    self.section_match = lambda x: section_pat.match(x)
    self.others_match = lambda x: others_pat.match(x)
    self.others_search = lambda x: others_pat.search(x)
    self.doc_match = lambda x: doc_pattern.match(x)
    self.code_match = lambda x: code_pattern.match(x)
    self.atdir_match = lambda x: atdir_pat.match(x)</t>
<t tx="vitalije.20170724110236.1">def section_ref(self, s):
    m = self.section_match(s)
    if m:
        return m.groups()
    return None, None, None</t>
<t tx="vitalije.20170724110308.1">def others_iterator(self, p):
    after = p.nodeAfterTree()
    p1 = p.threadNext()
    while p1 and p1 != after:
        if p1.isAtIgnoreNode() or self.section_ref(p1.h)[1]:
            p1.moveToNodeAfterTree()
        else:
            yield p1.copy()
            if self.others_search(p1.b):
                p1.moveToNodeAfterTree()
            else:
                p1.moveToThreadNext()
</t>
<t tx="vitalije.20170724110403.1">def section_replacer(self, it):
    for p, w, final in it:
        if final:
            yield p, w, final
            continue
        indent, sref, after = self.section_ref(w)
        if sref and not self.in_doc:
            if self.in_all:
                yield p, w, True
            else:
                p1 = g.findReference(sref, p)
                if not p1:
                    raise LookupError('unresolved section reference: %s'%w)
                yield p, self.sent_line('@+', sref, indent=indent), True
                for p2, w2, final in self.all_lines(p1):
                    w2 = indent + w2 if w2 != '\n' else w2
                    yield p2, w2, final
                yield p, self.sent_line('@-', sref, after, indent=indent), True
                self.in_doc = False
        else:
            yield p, w, final
</t>
<t tx="vitalije.20170724110553.1">def open_node(self, p):
    stlev = self.star_level(p.level() - self.zero_level)
    return  self.sent_line('@+node:', p.gnx, stlev, p.h)</t>
<t tx="vitalije.20170724110634.1">def body_lines(self, p):
    first = p.level() == self.zero_level
    if not first:
        yield p, self.open_node(p), True
    self.in_doc = False
    if p.b:
        for i, line in enumerate(g.splitLines(p.b)):
            # child nodes should use continue
            # if they need to skip following nodes
            @others
            yield p, line, False
        if not line.endswith('\n'):
            yield p, '\n', False
</t>
<t tx="vitalije.20170724110634.2">verbatim = self.needs_verbatim(line)
if verbatim:
    yield p, self.sent_line('@verbatim'), True
    yield p, line, True
    continue</t>
<t tx="vitalije.20170724110634.3">if first:
    if line.startswith('@first '):
        yield p, line[7:], True
        continue
    else:
        first = False
        yield p, self.sent_line('@+leo-ver=5-thin'), True
        yield p, self.open_node(p), True
        fstr = self.sent_line('@@first')
        for k in range(i):
            yield p, fstr, True
</t>
<t tx="vitalije.20170724110634.4">if not self.in_all:
    if line.startswith('@last '):
        self.last.append(line[6:])
        yield p, self.sent_line('@@last'), True
        continue
    elif self.last:
        g.error('@last must be last line in body')
        break</t>
<t tx="vitalije.20170724110820.1">def needs_verbatim(self, line):
    return line.lstrip().startswith(self.delim_st + '@')</t>
<t tx="vitalije.20170724110849.1">def others_replacer(self, it):
    for p, w, final in it:
        if final:
            yield p, w, final
            continue
        m = self.others_match(w)
        if m and not self.in_doc:
            if self.in_all:
                yield p, w, True
            else:
                indent = m.group(1)
                w1 = self.sent_line('@+others',indent=indent)
                yield p, w1, True
                for p1 in self.others_iterator(p):
                    for p2, w2, final in self.all_lines(p1):
                        w2 = indent + w2 if w2 != '\n' else w2
                        yield p2, w2, final
                yield p, self.sent_line('@-others',indent=indent), True
                self.in_doc = False
        else:
            yield p, w, final</t>
<t tx="vitalije.20170724111016.1">def atall_replacer(self, it):
    for p, w, final in it:
        if final:
            yield p, w, final
            continue
        if w == '@all\n':
            self.in_all = True
            self.in_doc = False
            yield p, self.sent_line('@+all'), True
            for p1 in p.subtree_iter():
                for p2, w2, final in self.all_lines(p1):
                    yield p2, w2, final
            yield p, self.sent_line('@-all'), True
            self.in_all = False
            self.in_doc = False
        else:
            yield p, w, final</t>
<t tx="vitalije.20170724111114.1"># for debugging
def log_it(self, name, it):
    if not hasattr(self, 'log_levels'):
        self.log_levels = Counter()
    n = self.log_levels[name]
    self.log_levels[name] += 4
    m = '%s[%s'%(' '*n, name.ljust(10))
    for p, w, final in it:
        m1 = m+'F]' if final else m + '*]'
        g.pr(m1, p.gnx, w, newline=False)
        yield p, w, final</t>
<t tx="vitalije.20170724112136.1">def all_lines(self, p):
    trace = False
    if trace:
        it = self.body_lines(p)
        it = self.log_it('body_lines', it)
        it = self.atall_replacer(it)
        it = self.log_it('all_repl', it)
        it = self.section_replacer(it)
        it = self.log_it('sec_repl', it)
        it = self.others_replacer(it)
        it = self.log_it('oth_repl', it)
        it = self.at_adder(it)
        it = self.log_it('at_adder', it)
        it = self.at_docer(it)
        it = self.log_it('at_docer', it)
    else:
        it = self.body_lines(p)
        it = self.atall_replacer(it)
        it = self.section_replacer(it)
        it = self.others_replacer(it)
        it = self.at_adder(it)
        it = self.at_docer(it)
    return it
</t>
<t tx="vitalije.20170724112249.1">def at_docer(self, it):
    for p, w, final in it:
        if final or self.in_all:
            yield p, w, final
            continue
        @others
        if self.in_doc and not self.delim_en:
            yield p, self.sent_line(' ', w[:-1]), True
        else:
            yield p, w, False</t>
<t tx="vitalije.20170724112249.2">m = self.doc_match(w)
if m:
    self.in_doc = True
    docdir = '@+at' if m.group(1) == '@' else '@+doc'
    docline = ' ' + m.group(2) if m.group(2) else ''
    yield p, self.sent_line(docdir, docline), True
    if self.delim_en:
        yield p, self.delim_st + '\n', True
    continue</t>
<t tx="vitalije.20170724112249.3">m = self.code_match(w)
if m:
    if self.delim_en:
        yield p, self.delim_en  + '\n', True
    yield p, self.sent_line('@', m.group(1)), True
    self.in_doc = False
    continue</t>
<t tx="vitalije.20170724112531.1">def at_adder(self, it):
    for p, w, final in it:
        if final:
            yield p, w, final
            continue
        m = self.atdir_match(w)
        if m and not self.in_all:
            yield p, self.sent_line('@', w[:-1]), True
        else:
            yield p, w, False</t>
<t tx="vitalije.20170724113036.1">def star_level(self, lev):
    if lev &lt; 2:
        return [': * ', ': ** '][lev]
    else:
        return ': *%d* '%(lev + 1)</t>
<t tx="vitalije.20170724113053.1">def sent_line(self, s1, s2='', s3='', s4='', indent=''):
    return ''.join(
        (
            indent,
            self.delim_st,
            s1, s2, s3, s4,
            self.delim_en,
            '\n'
        ))</t>
<t tx="vitalije.20170724113216.1">def to_lines(self, p=None):
    if p:
        self.p = p
        self.zero_level = p.level()
    self.last = []
    for p1, line, final in self.all_lines(self.p):
        yield line
    yield self.sent_line('@-leo')
    for line in self.last:
        yield line
4</t>
<t tx="vitalije.20170724113906.1">def test_compare_n2(n, quiet=False, unclutter=True):
    ok = False
    with testfile(n, quiet, unclutter) as p:
        try:
            lines = get_lines(n)
            conf = get_conf(p)
            log = deque(maxlen=5)
            dfw = DerivedFileWriter(c, p, conf.delim_st, conf.delim_en)
            it = dfw.to_lines()
            for i, line in enumerate(lines):
                line2 = next(it,'------ None ------')
                log.append((i, line, line2))
                if line != line2:
                    ok = False
                    for n, a, b in log:
                        g.es(n+1, a, newline=False)
                        g.es(n+1, b, color='blue', newline=False)
                    g.es('r', repr(line))
                    g.es('r', repr(line2))
                    if False:
                        for j in range(i+1, i+5):
                            g.es(j, lines[j], newline=False)
                            g.es(j, next(it), newline=False, color='yellow')
                    break
            else:
                ok = True
        except Exception as e:
            g.es_exception(e)
    g.es('.' if ok else 'E', newline=False)
    return ok</t>
<t tx="vitalije.20170724114036.1">def test_works_ok2():
    errs = list()
    for i, (n, fn) in enumerate(valid_files()):
        ok = test_compare_n2(n, unclutter=True, quiet=True)
        if not ok:
            errs.append(n)
        if i % 35 == 34:
            g.es('')
        if i == 4000:break
    c.redraw()
    g.es('\n finished testing')
    if errs:
        g.es(errs[:5])
    else:
        g.es('success')</t>
<t tx="vitalije.20170724122803.1">import itertools
import re
import leo.core.leoNodes as leoNodes
import difflib
import timeit
import pprint
from contextlib import contextmanager
from collections import deque, Counter, defaultdict
@others
cls()
#do_import_file(0)
#ok = compare_reading_all_files()
#diffs = compare_reading_file(0, quiet=False)
#dump_diffs(diffs)
#c.redraw()
profile_this(395, 10)
g.es('the end')</t>
<t tx="vitalije.20170724123641.1">def compare_reading_file(n, quiet=True, unclutter=True):
    diffs = {}
    def compare_node_attributes(v, attrs, i):
        gnx, h, b, lev = attrs
        assert v.gnx == gnx, 'node [%d]\n%s was expected\n%s received'%(i, v.gnx, gnx)
        assert v.h == h, 'node [%d]\n%s was expected\n%s received'%(i, v.h, h)
        if v.b != b:
            diffs[gnx] = (encoded_diff(v.b, b),v.h)
            raise ValueError(b +'\n' + gnx +':' + h)

    with testfile(n, quiet, unclutter) as p:
        lines = get_lines(n)
        it = load_derived_file(lines)
        for i, (p1, gnx_h_b_lev) in enumerate(zip(p.self_and_subtree(), it)):
            lev = gnx_h_b_lev[-1]
            explev = p1.level() - p.level()
            compare_node_attributes(p1.v, gnx_h_b_lev, i)
            assert explev == lev, 'wrong level expected[%s] got[%d]'%(explev, lev)
    return diffs
</t>
<t tx="vitalije.20170724123645.1">def compare_reading_all_files():
    outpos = 0
    ok = True
    for i, fn in valid_files():
        diffs = compare_reading_file(i)
        if diffs:
            ok = False
            g.es('E', newline=outpos % 35 == 34)
            # break
        else:
            g.es('.', newline=outpos % 35 == 34)
        outpos += 1
    else:
        ok = True
    g.es('')
    return ok
</t>
<t tx="vitalije.20170724131900.1"></t>
<t tx="vitalije.20170724131900.2">if g.isPython3:
    from functools import lru_cache as cache, wraps
else:
    from functools import wraps
    def cache(func, maxsize=None):
        saved = {}
        @wraps(func)
        def newfunc(*args):
            if args in saved:
                return saved[args]
            result = func(*args)
            saved[args] = result
            return result
        return newfunc</t>
<t tx="vitalije.20170724133732.1">def load_derived_file(lines):
    flines = tuple(enumerate(lines))
    first_lines = []
    conf = g.bunch(
        delim_st = '#',
        delim_en = '',
    )
    @others
</t>
<t tx="vitalije.20170724140140.1">header_pattern = re.compile(r'''
    ^(.+)@\+leo
    (-ver=(\d+))?
    (-thin)?
    (-encoding=(.*)(\.))?
    (.*)$''', re.VERBOSE)

for i, line in flines:
    m = header_pattern.match(line)
    if m:
        break
    first_lines.append(line)
else:
    raise ValueError('wrong format, not derived file')
# m.groups example ('#', '-ver=5', '5', '-thin', None, None, None, '')
delim_st = m.group(1)
delim_en = m.group(8)
</t>
<t tx="vitalije.20170724150424.1">@
   Find beginning of top (root node) of this derived file.
   We expect zero or more first lines before leo header line.

   Leo header line will give usefull information such as delimiters.</t>
<t tx="vitalije.20170724150825.1"># we need to skip twice the number of first_lines, one header line
# and one top node line
start = 2 * len(first_lines) + 2

# keeps track of current indentation
indent = 0 

# keeps track of current node that we are reading
gnx = topgnx

# list of lines for current node
body = nodes.body[gnx]


for i, line in flines[start:]:
    # child nodes may if necessary shortcut this loop
    # using continue or let the line fall through to 
    # the end of loop
    @others

    # nothing special about this line, let's append it to current body
    body.append(line)


if i + 1 &lt; len(flines):
    nodes.body[topgnx].extend('@last %s'%x for x in flines[i+1:])</t>
<t tx="vitalije.20170724151357.1">@ utility function to set data from regex match object from sentinel line
  see node_start pattern. groups[1 - 5] are:
  (indent, gnx, level-number, second star, headline)
      1      2         3            4          5
  returns gnx
@c
def set_node(m):
    gnx = m.group(2)
    lev = int(m.group(3)) if m.group(3) else 1 + len(m.group(4))
    nodes.level[gnx].append(lev)
    nodes.head[gnx] = m.group(5)
    nodes.gnxes.append(gnx)
    return gnx

</t>
<t tx="vitalije.20170724151900.1">@ if we are using delim_en for closing comment, 
  then doc parts start with delim_st alone on line
  and doc parts end with delim_en alone on line

   so whenever we encounter any of this lines, 
   we have just to skip and nothing should be added to body.
@c
doc_skip = (delim_st + '\n', 
            delim_en + '\n')
</t>
<t tx="vitalije.20170724152531.1">if verbatim:
    # previous line was verbatim sentinel. let's append this line as it is
    body.append(line)

    verbatim = False # (next line should be normally processed)
    continue

if line == verbline:
    # this line is verbatim sentinel, next line should be appended as it is
    verbatim = True
    continue
</t>
<t tx="vitalije.20170724152616.1">m = patterns.all.match(line)
if m:
    in_all = m.group(2) == '+' # is it opening or closing sentinel
    if in_all:
        # opening sentinel
        body.append('@all\n')
        # keep track which node should we continue to build
        # once we encounter closing at-all sentinel
        stack.append((gnx, indent))
    else:
        # this is closing sentinel
        # let's restore node where we started at-all directive
        gnx, indent = stack.pop()
        # restore body which should receive next lines
        body = nodes.body[gnx]
    continue
</t>
<t tx="vitalije.20170724152800.1">m = patterns.others.match(line)
if m:
    in_doc = False
    if m.group(2) == '+': # is it opening or closing sentinel
        # opening sentinel
        body.append(m.group(1) + '@others\n')
        # keep track which node should we continue to build
        # once we encounter closing at-others sentinel
        stack.append((gnx, indent))
        indent += m.end(1) # adjust current identation
    else:
        # this is closing sentinel
        # let's restore node where we started at-others directive
        gnx, indent = stack.pop()
        # restore body which should receive next lines
        body = nodes.body[gnx]
    continue</t>
<t tx="vitalije.20170724153641.1">if not in_doc:
    # we are not yet in doc part
    # maybe we are at the beginning of doc part
    m = patterns.doc.match(line)
    if m:
        # yes we are at the beginning of doc part
        # was it @+at or @+doc?
        doc = '@doc' if m.group(1) == 'doc' else '@'
        doc2 = m.group(2) or '' # is there any text on first line?
        if doc2:
            # start doc part with some text on the same line
            body.append('%s%s\n'%(doc, doc2))
        else:
            # no it is only directive on this line
            body.append(doc + '\n')

        # following lines are part of doc block
        in_doc = True
        continue
</t>
<t tx="vitalije.20170724155749.1">if in_doc:
    # we are in doc part

    # when using both delimiters, doc block starts with first delimiter
    # alone on line and at the end of doc block end delimiter is also
    # alone on line. Both of this lines should be skipped

    if line in doc_skip: continue

    # maybe this line ends doc part and starts code part?
    m = patterns.code.match(line)
    if m:
        # yes, this line is at-c or at-code line

        in_doc = False  # stop building doc part

        # append directive line
        body.append('@code\n' if m.group(1) else '@c\n')
        continue
</t>
<t tx="vitalije.20170724162219.1">m = patterns.section.match(line)
if m:
    in_doc = False

    if m.group(2) == '+': # is it opening or closing sentinel
        # opening sentinel
        ii = m.end(2) # before &lt;&lt;
        jj = m.end(3) # at the end of line
        body.append(m.group(1) + line[ii:jj] + '\n')

        # keep track which node should we continue to build
        # once we encounter closing at-&lt;&lt; sentinel
        stack.append((gnx, indent))

        indent += m.end(1) # adjust current identation
    else:
        # this is closing sentinel

        # let's restore node where we started at+&lt;&lt; directive
        gnx, indent = stack.pop()

        # restore body which should receive next lines
        body = nodes.body[gnx]
    continue
</t>
<t tx="vitalije.20170724162943.1">m = patterns.node_start.match(line)
if m:
    in_doc = False
    gnx = set_node(m)
    if len(nodes.level[gnx]) &gt; 1:
        # clone in at-all
        # let it collect lines in throwaway list
        body = []
    else:
        body = nodes.body[gnx]
    continue</t>
<t tx="vitalije.20170724164635.1">for gnx in nodes.gnxes:
    b = ''.join(nodes.body[gnx])
    h = nodes.head[gnx]
    lev = nodes.level[gnx].pop(0)
    yield gnx, h, b, lev-1</t>
<t tx="vitalije.20170724165032.1"># this is where we will collect all the data from input
nodes = g.bunch(
    # level must contain lists of node levels in order they appear in input
    # this is to support at-all directive which will write clones several times.
    level = defaultdict(list),

    # contains headline for each node
    head = {},

    # contains lines of body text for each node
    body = defaultdict(list),

    # this is list which will store the order of nodes in derived file
    # that is the order in which we will dump nodes once we have consumed
    # all input lines
    gnxes = [],
)</t>
<t tx="vitalije.20170724165103.1">topnodeline = flines[len(first_lines) + 1][1] # line after header line

m = patterns.node_start.match(topnodeline)
topgnx = set_node(m)

# append first lines if we have some
nodes.body[topgnx] = ['@first '+ x for x in first_lines]
assert topgnx, 'top node line [%s] %d first lines'%(topnodeline, len(first_lines))

# this will keep track of current gnx and indent whenever we encounter 
# at+others or at+&lt;section&gt; or at+all
stack = []

in_all = False
in_doc = False


# spelling of at-verbatim sentinel
verbline = delim_st + '@verbatim' + delim_en + '\n'

verbatim = False # keeps track whether next line is to be processed or not</t>
<t tx="vitalije.20170724170729.1">if line.startswith(delim_st + '@-leo'):
    break
</t>
<t tx="vitalije.20170724195630.1"># is indent still valid?
if indent and line[:indent].isspace() and len(line) &gt; indent:
    # yes? let's strip unnecessary indentation
    line = line[indent:]</t>
<t tx="vitalije.20170724201626.1">if line.startswith(delim_st + '@@'):
    ii = len(delim_st) + 1 # on second '@'

    # strip delim_en if it is set or just '\n'
    jj = line.rfind(delim_en) if delim_en else -1

    # append directive line
    body.append(line[ii:jj] + '\n')
    continue</t>
<t tx="vitalije.20170724203034.1">if in_doc and not delim_en:
    # when using just one delimiter (start)
    # doc lines start with delimiter + ' '
    body.append(line[len(delim_st)+1:])
    continue
# when delim_en is not '', doc part starts with one start delimiter and \n
# and ends with end delimiter followed by \n
# in that case doc lines are unchcanged</t>
<t tx="vitalije.20170724203519.1">import re
delim_st = '#'
delim_en = ''
@others
m = patterns.code.match('#@@c\n')
g.es(m.groups() if m else 'None')
</t>
<t tx="vitalije.20170724214159.1"># this function can be avoided and its calculations made inline
# but if we should support change in delims during the read
# process it would be better if we have this as a function
def get_patterns(delim_st, delim_en):
    if delim_en:
        dlms = re.escape(delim_st), re.escape(delim_en)
        ns_src = r'^(\s*)%s@\+node:([^:]+): \*(\d+)?(\*?) (.*?)%s$'%dlms
        sec_src = r'^(\s*)%s@(\+|-)&lt;{2}[^&gt;]+&gt;&gt;(.*?)%s$'%dlms
        oth_src = r'^(\s*)%s@(\+|-)others%s\s*$'%dlms
        all_src = r'^(\s*)%s@(\+|-)all%s\s*$'%dlms
        code_src = r'^%s@@c(ode)?%s$'%dlms
        doc_src = r'^%s@\+(at|doc)?(\s.*?)?%s$'%dlms
    else:
        dlms = re.escape(delim_st)
        ns_src = r'^(\s*)%s@\+node:([^:]+): \*(\d+)?(\*?) (.*)$'%dlms
        sec_src = r'^(\s*)%s@(\+|-)&lt;{2}[^&gt;]+&gt;&gt;(.*)$'%dlms
        oth_src = r'^(\s*)%s@(\+|-)others\s*$'%dlms
        all_src = r'^(\s*)%s@(\+|-)all\s*$'%dlms
        code_src = r'^%s@@c(ode)?$'%dlms
        doc_src = r'^%s@\+(at|doc)?(\s.*?)?'%dlms + '\n'
    return g.bunch(
        node_start = re.compile(ns_src),
        section    = re.compile(sec_src),
        others     = re.compile(oth_src, re.DOTALL),
        all        = re.compile(all_src, re.DOTALL),
        code       = re.compile(code_src),
        doc        = re.compile(doc_src),
    )</t>
<t tx="vitalije.20170724230235.1">24-07-2017 10:17:47

Today I am going to test performance with this code, and some variants of it,
and probably I will make class and profile it also.

24-07-2017 10:43:12

Profiling two variants on both Python2.7 and Python3 gave negligible (&lt;1ms) difference
between them. It proves that Python is clever enough to create helper functions only
once.

variant 1: define make_py_to_lines and execute it once and store result to p_to_lines
           then delete make_py_to_lines.

variant 2: turn make_py_to_lines into p_to_lines.

24-07-2017 12:18:37

created DerivedFileWriter - class implementing method .to_lines

profiling DerivedFileWriter and p_to_lines shows that p_to_lines is
about 15% faster then DerivedFileWriter. On my machine writing 
leo/core/leoCommands.py takes:

    1. DerivedFileWriter - 108ms
    2. p_to_lines - 93.3ms

It seems that all helpers inside one exported function approach is better (at least
in this case) than more OO approach.</t>
<t tx="vitalije.20170724231905.1">def profile_this(n, num):
    with testfile(n, quiet=True,  unclutter=True) as p:
        txt = get_file(n)
        def at_read_p():
            c.atFileCommands.read(p, force=True, fromString=txt)

        def new_load():
            return tuple(load_derived_file(get_lines(n)))

        ms = 1000*timeit.timeit(at_read_p, number=num)/num
        g.unitTesting = False
        g.es('v1: average time: %4.1f ms'%ms)

        ms = 1000*timeit.timeit(new_load, number=num)/num
        g.es('v2: average time: %4.1f ms'%ms)</t>
</tnodes>
</leo_file>
